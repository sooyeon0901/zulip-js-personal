/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var cw;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./browser/zulip_cherry_main.js":
/*!**************************************!*\
  !*** ./browser/zulip_cherry_main.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\n\n /* eslint-disable */\nconst { async } = __webpack_require__(/*! @babel/runtime/helpers/regeneratorRuntime */ \"./node_modules/@babel/runtime/helpers/regeneratorRuntime.js\");\nconst zulip = __webpack_require__(/*! ../lib */ \"./lib/index.js\");\n\nconst hashReplacements = new Map([\n  [\"%\", \".\"],\n  [\"(\", \".28\"],\n  [\")\", \".29\"],\n  [\".\", \".2E\"],\n]);\n\nclass CZulip {\n  constructor(email, apiKey, uri) {\n    this.z = zulip({username: email, apiKey, realm: uri});\n  }\n  async getZulip() {\n    return this.z;\n  }\n\n  // eventHandler(event)\n  async callOnEachMessage(eventHandler)  {\n    const z = await this.z;\n    z.callOnEachEvent(eventHandler, ['message']);\n  }\n  \n  /* -------------------\n  *     stream 관련 \n  * -------------------- */\n /**\n  *  [ 나의 구독(공개/비공개된) 전체 스트림 조회 ] **(나의)팔로잉\n  */\n  async getStreams() {\n    const z = await this.z;\n    return z.streams.subscriptions.retrieve();    \n  }\n\n /**\n  * [ 전체 스트림 조회 ] **모든 유저가 가입한 스트림 조회\n  *   비공개방 + 해당 유저가 존재O == 조회O\n  *   비공개방 + 해당 유저가 존재X == 조회X\n  *   (admin이어도 동일하게 적용됨)\n  *   @ex) removeStreamSubscription(\"군고구마방-공개\")\n  */\n  async getAllStreams(){\n    const z = await this.z;\n    return await z.streams.retrieve();\n  }\n  \n /**\n  * [ 스트림 id로 각 스트림 정보 조회 ]\n  * @param {*} stream_id(필수), json 형식 {\"stream_id\": 39}\n  * @ex) getStreamById({\"stream_id\": 39})\n  */\n  async getStreamById(stream_id){\n    const z = await this.z;\n    const param = {\n      stream_id: stream_id\n    }\n    return z.streams.getStreamById(param);\n  }\n  \n /**\n  * [ 스트림명으로 해당 스트림의 ID 조회 ]\n  * @param {*} stream_name(필수) \n  *  @ex) getOneStreamId(\"단체1-공개\")\n  */\n  async getOneStreamId(stream_name){\n    const z = await this.z;\n    return z.streams.getStreamId(stream_name);\n  }\n\n /**\n  * [ 유저의 스트림 구독 상태 조회 ] (관리자) \n  * @param {*} user_id(필수), stream_id(필수)\n  * @param {*} stream_id \n  * @ex) getUsersStreams(22, 42)\n  */\n  async getUsersStreams(user_id, stream_id) {\n    const z = await this.z;\n    const params = {\n      user_id: user_id,\n      stream_id: stream_id\n    };\n    return z.streams.subscriptions.status(params);    \n  }\n\n /**\n  *  [ 해당 스트림을 구독하는 구독자들 id 조회 ] **팔로워 조회\n  * @param {*} stream_id(필수)\n  * @ex) getAllSubscribers(39)\n  */\n  async getAllSubscribers(stream_id) {\n    const z = await this.z;\n    const params = {\n      stream_id: stream_id\n    };\n    return z.streams.subscriptions.allSubscribers(params);\n  }\n\n /**\n  * [ 해당 스트림의 설정 변경 ] (관리자)\n  * @param {*} param (JSON형식)\n  * subscription_data (필수) = [{ stream_id, property, value }]\n  * @ex) getAllSubscribers(39)\n  */\n  async setSubscriptionSetting(param){\n    const z = await this.z;\n    const params = {\n      subscription_data : [param]\n    };\n    return z.users.me.subscriptions.properties(params);\n  }\n\n /**\n  * [ 스트림 업데이트 ] admin만 가능\n  * @param {*} (JSON형식) stream_id(필수), description, new_name, is_private, stream_post_policy\n  */\n  async updateStream(param){\n    const z = await this.z;\n    const send_param = new Object();\n    const key_arr = [];\n    let keys = Object.keys(param);\n    for (let i = 0; i < keys.length; i++) {\n    \tlet key = keys[i];\n      key_arr.push(key);\n    }\n\n    if(key_arr.includes(\"stream_id\")){// 필수 파라미터\n      send_param.stream_id = param[\"stream_id\"];\n    } \n    if(key_arr.includes(\"description\")){\n      send_param.description = param[\"description\"];\n    } \n    if(key_arr.includes(\"new_name\")){\n      send_param.new_name = param[\"new_name\"];\n    } \n    if(key_arr.includes(\"is_private\")){\n      send_param.is_private = param[\"is_private\"];\n    } \n    if(key_arr.includes(\"stream_post_policy\")){\n      send_param.stream_post_policy = param[\"stream_post_policy\"];\n    } \n    \n    // message_retention_days: JSON.stringify(param.message_retention_days) // Owner일 때만 사용가능한 파라미터\n    // history_public_to_subscribers: history_public_to_subscribers, // 디폴트 사용\n    // is_web_public // 웹 공개 스트림인지 여부\n    return z.streams.subscriptions.update(send_param);\n  }\n\n /**\n  * [ 나의 새 스트림 생성(create) 및 기존 스트림 구독 ] **팔로잉 action\n  * @param {*} (JSON형식) user_id(필수), stream_name(필수), stream_post_policy(필수)\n  * stream_name이 존재하지 않으면 새 스트림을 생성하고, 존재하는 스트림이 미구독 상태이면 구독함\n  * @ex) subscribeStream(\"연말모임\")\n  */\n  async subscribeStream(param){ \n    const z = await this.z;\n    const params = {\n      subscriptions: JSON.stringify([{name: param.stream_name, description: param.description}]),\n      stream_post_policy: param.stream_post_policy,\n      // message_retention_days의 값을 지정하여 스트림 생성하는 건 owner만 할 수 있음.\n      // message_retention_days: JSON.stringify(param.message_retention_days) // str, int 두 개의 타입을 모두 받을 수 있기 때문에 stringify 처리해야 동작됨\n      // announce: \"true\", // true를 string으로 넘겨야 에러 안남, 어떤 효과인지 모르겠음. 디폴트 설정이 나을듯함\n      // is_web_public: \"true\", // 설정을 연결해서 처리해야 할 게 많음. 보류\n      // history_public_to_subscribers 옵션은 필요없을 거 같아서 테스트 안함\n    };\n    return z.users.me.subscriptions.add(params);\n  }\n\n /**\n  * [ 스트림에 해당 유저 추가 ]\n  * @param {*} user_id(필수), stream_name(필수)\n  * stream_name이 존재하지 않으면 새 스트림을 생성함\n  * @ex) subscribeAnotherUserStream(22, \"군고구마방-공개\")\n  */\n  async subscribeAnotherUserStream(user_id, stream_name){\n    const z = await this.z;\n    // 새 스트림/기존 스트림에 유저 추가\n    const params = {\n      subscriptions: JSON.stringify([{name: stream_name}]),\n      principals: JSON.stringify([user_id]),\n    };\n    return z.users.me.subscriptions.add(params);\n  }\n\n /**\n  * [ 나의 스트림 구독 취소 ] **(나의)팔로우 취소\n  * @param {*} stream_name(필수)\n  * @ex) removeStreamSubscription(\"군고구마방-공개\")\n  */\n  async removeStreamSubscription(stream_name){\n    const z = await this.z;\n    const params = {\n      subscriptions: JSON.stringify([stream_name]),\n    };\n    return z.users.me.subscriptions.remove(params);\n  }\n\n /**\n  * [ 해당 유저의 스트림 구독 취소 ] **(유저의)팔로우 취소\n  * @param {*} (JSON형식) user_id(필수), stream_name(필수)\n  * @ex) removeAnotherUserSubscription(\"\")\n  */\n  async removeAnotherUserSubscription(param){\n    const z = await this.z;\n    const params = {\n      subscriptions: JSON.stringify(param.subscriptions),\n      principals: JSON.stringify(param.principals), // 유저의 id or email\n    };\n    return z.users.me.subscriptions.remove(params);\n  }\n\n /**\n  * [ 해당 스트림 삭제 ]\n  * @param {*} stream_id(필수) \n  * @ex) deleteStream({\"stream_id\": 44})\n  */\n  async deleteStream(stream_id) {\n    const z = await this.z;    \n    const param = {\n      stream_id: stream_id\n    }; \n    return z.streams.deleteById(param);\n  }\n\n /**\n  * [ 해당 스트림에서 토픽 조회 ]\n  * @param {*} stream_id(필수) \n  * @ex) getStreamTopics({\"stream_id\": 39})\n  */\n  async getStreamTopics(stream_id){\n    const z = await this.z;   \n    const param = {\n      stream_id: stream_id\n    }; \n    return z.streams.topics.retrieve(param);\n  }\n\n /**\n  * [ 토픽 뮤트/언뮤트 ]\n  * @param {*} stream(필수), topic(필수), op(add/remove)(필수) \n  * @ex) muteTopic(\"뮤트테스트\", \"뮤트토픽\", \"add/remove\")\n  */\n  async muteUnmuteTopic(stream, topic, op){\n    const z = await this.z;\n    const params = {\n      stream: stream,\n      topic: topic,\n      op: op,\n    }\n    return z.streams.topics.mutedTopics(params);\n  }\n\n /**\n  * [ 토픽 삭제 ]\n  * @param {*} stream_id(필수), topic_name(필수)\n  * @ex) deleteTopic(39, \"재밌는토픽01\")\n  */\n  async deleteTopic(stream_id, topic_name){\n    const z = await this.z;    \n    const params = {\n      topic_name: topic_name,\n      stream_id: stream_id\n    }\n    return z.streams.topics.delete(params);\n  }\n\n /**\n  * [ default stream 설정 ]\n  * @param {*} stream_id(필수)\n  * @ex) setDefaultStream(39) \n  */\n  async setDefaultStream(stream_id){\n    const z = await this.z;\n    const params = {\n      stream_id: stream_id,\n    }\n    return z.streams.defaultStream.add(params);\n  }\n\n /**\n  * [ remove default stream 설정 ]\n  * @param {*} stream_id (필수)\n  * @ex) removeDefaultStream(39) \n  */\n  async removeDefaultStream(stream_id){\n    const z = await this.z;\n    const params = {\n      stream_id: stream_id,\n    }\n    return z.streams.defaultStream.remove(params);\n  }\n  \n  /* -------------------\n  *     message 관련 \n  * -------------------- */\n /**\n  * [ 메시지 랜더링 ]\n  * @param {*} msg(필수)\n  * @returns \n  */\n  async messageRender(msg) {\n    const z = await this.z;\n    return z.messages.render(msg);\n  }\n\n /**\n  * [ 스트림에 메시지 보내기 ]\n  * @param {*} stream(필수), topic(필수), msg(필수)\n  * @ex)  sendStreamMsg(\"신년모임\", \"stream events\", \"메시지가나요?\")\n  */\n  async sendStreamMsg(stream, topic, msg){\n    const z = await this.z;\n    const params = {\n        to: stream,\n        type: 'stream',\n        subject: topic, \n        content: msg\n    };\n    return z.messages.send(params);\n  }\n\n /**\n  * [ private 메시지 보내기 ]\n  * @param {*} (JSON형식) userId(받는 사람 id), msg(보낼 메시지)\n  */\n  async sendPrivateMsg(param){\n    const z = await this.z;\n    const params = {\n      to: param.userId,\n      type: 'private',\n      content: param.msg\n    };\n    return z.messages.send(params);\n  }\n\n /**\n  * [ 스트림에 파일 업로드 ] api를 따로 호출해서 사용중 (미사용)\n  */\n  async uploadFile(){\n    const z = await this.z;\n    return z.messages.file.upload;\n  }\n\n /**\n  * [ 메시지 정보 조회 ]\n  * @param {*} narrowParams (JSON형식)\n  * @param {*} otherParams (JSON형식)\n  * https://zulip.com/api/get-messages\n  */\n  async getMsg(narrowParams, otherParams){\n    const z = await this.z;\n    const params = {\n      anchor: otherParams.anchor,\n        num_before: otherParams.num_before, // 엥커보다 작은 메시지의 개수. ex) 1 == 1개, 3 == 3개 출력\n        num_after: otherParams.num_after, // 엥커보다 큰 메시지의 개수. 다른 수로 테스트해도 결과값이 다르지 않음.\n        narrow: narrowParams,\n        client_gravatar: otherParams.client_gravatar, // false로 지정하면 avatar_url이 null이 아닌 값이 들어가 있음. 그 값은 작성자의 아바타, 프로필이미지.\n        apply_markdown: otherParams.apply_markdown, // false인 경우, 마크다운 형식으로 출력. true인 경우 랜더링된 html형식.\n        // use_first_unread_anchor: true // first_unread 와 같이 사용. \n    }\n    return z.messages.retrieve(params);\n  }\n\n /**\n  * [ 메시지  전체 조회 ]\n  * @param {*} otherParams (JSON형식)\n  * https://zulip.com/api/get-messages\n  */\n  async getMsgNoNarrow(otherParams){\n    const z = await this.z;\n    const params = {\n      anchor: otherParams.anchor,\n      num_before: otherParams.num_before, \n      num_after: otherParams.num_after, \n      client_gravatar: otherParams.client_gravatar,\n      apply_markdown: otherParams.apply_markdown\n    }\n    return z.messages.retrieve(params);\n  }\n\n  /**\n   * [ 메시지 수정 ]\n   * 23.06.08 수정사항 suyeoun.kim\n   * - api.js의 21 line에 PATCH도 추가\n   * @param {*} param (JSON형식) message_id(필수), content, topic, propagate_mode, send_notification_to_old_thread, send_notification_to_new_thread, stream_id\n   * 함께 사용하면 안되는 파라미터가 있어서 DOC 확인 / https://zulip.com/api/update-message\n   */\n  async editMsg(param){\n    const z = await this.z;\n    const send_param = new Object();\n    const key_arr = [];\n    let keys = Object.keys(param);\n    for (let i = 0; i < keys.length; i++) {\n    \tlet key = keys[i];\n      key_arr.push(key);\n    }\n\n    if(key_arr.includes(\"message_id\")){\n      send_param.message_id = param[\"message_id\"];\n    } \n    if(key_arr.includes(\"content\")){\n      send_param.content = param[\"content\"];\n    } \n    if(key_arr.includes(\"topic\")){\n      send_param.topic = param[\"topic\"];\n    } \n    if(key_arr.includes(\"propagate_mode\")){\n      send_param.propagate_mode = param[\"propagate_mode\"];\n    } \n    if(key_arr.includes(\"send_notification_to_old_thread\")){\n      send_param.send_notification_to_old_thread = param[\"send_notification_to_old_thread\"];\n    } \n    if(key_arr.includes(\"send_notification_to_new_thread\")){\n      send_param.send_notification_to_new_thread = param[\"send_notification_to_new_thread\"];\n    } \n    if(key_arr.includes(\"stream_id\")){\n      send_param.stream_id = param[\"stream_id\"];\n    }\n    return z.messages.update(send_param);\n  }\n\n /**\n  *  [ 메시지 삭제 ]\n  * @param {*} message_id(필수)\n  */\n  async deleteMsg(message_id){\n    const z = await this.z;\n    const params = {\n      message_id: message_id,\n    }\n    return z.messages.deleteById(params)\n  }\n\n /**\n  * [ 이모지 조회 ]\n  * https://zulip.com/api/get-custom-profile-fields\n  */\n  async getEmoji(){\n    const z = await this.z;\n    return z.emojis.retrieve();\n  }\n\n /**\n  * [ 메시지에 이모지 추가 ]\n  * @param {*} message_id(필수), emoji_name(필수)\n  */\n  async addEmojiReaction(message_id, emoji_name){\n    const z = await this.z;\n    const params = {\n      message_id: message_id,\n      emoji_name: emoji_name,\n      // emoji_code: emoji_code, // 옵션. 에러는 안나지만 이모지가 추가 안됨.\n      // reaction_type: 'unicode_emoji', // 그 외 타입 : realm_emoji, zulip_extra_emoji \n    }\n    return z.messages.emoji.add(params);\n  }\n\n /**\n  * [ 메시지에 이모지 삭제 ]\n  * @param {*} message_id(필수) , emoji_name(필수)\n  * @ex) removeEmojiReaction(470, \"octopus\")\n  */\n  async removeEmojiReaction(message_id, emoji_name){\n    const z = await this.z;\n    const params = {\n      message_id: message_id,\n      emoji_name: emoji_name,\n      // emoji_code: emoji_code, \n      reaction_type: 'realm_emoji', \n    }\n    return z.messages.emoji.remove(params);\n  }\n\n /**\n  *  [ 단일 메시지 조회 ]\n  * @param {*} param (JSON형식) message_id(필수), apply_markdown(필수)\n  * @ex) getSingleMsg(470)\n  */\n  async getSingleMsg(param){\n    const z = await this.z;\n    const params = {\n      message_id: param.message_id,\n      apply_markdown: param.apply_markdown, // 읽기 편한 방식. raw Markdown-format\n    }\n    return z.messages.getById(params);\n  }\n\n /**\n  * [ 메시지 수정 내역 조회 ] \n  * @param {*} message_id (필수)\n  * @ex) getEditHistory(471)\n  */\n   async getEditHistory(message_id){\n    const z = await this.z;\n    const params = {\n      message_id: message_id\n    }\n    return z.messages.getHistoryById(params);\n   }\n\n /**\n  *  [ 플래그 업데이트 ] \n  * @param {*} param (JSON형식) message_ids(필수), flag(필수)\n  * @ex) updateFlag([471, 472])\n  */\n  async updateFlag(param){\n    const z = await this.z;\n    const params = {\n      messages: param.message_ids,\n      flag: param.flag,\n    }\n    return z.messages.flags.add(params);\n  }\n\n /**\n  * [ 플래그 삭제 ] \n  * @param {*} param (JSON형식) message_ids(필수), flag(필수)\n  * @ex) removeFlag([471, 472])\n  */\n  async removeFlag(param){\n    const z = await this.z;\n    const params = {\n      messages: param.message_ids,\n      flag: param.flag,\n    }\n    return z.messages.flags.remove(params);\n  }\n\n /**\n  * [ 모든 글 읽음 상태로 전환 ] 이슈: 안됨\n  * @ex) markAllMsgAsRead()\n  */\n  async markAllMsgAsRead(){\n    const z = await this.z;\n    return z.messages.read.readAll();\n  }\n\n /**\n  * [ 스트림 글 읽음 상태로 전환 ] \n  * @param {*} stream_id (필수)\n  * @ex) markStreamMsgAsRead(48)\n  */\n  async markStreamMsgAsRead(stream_id){\n    const z = await this.z;\n    const params = {\n      stream_id: stream_id\n    }\n    return z.messages.read.streamAll(params);\n  }\n\n /**\n  * [ 토픽 글 읽음 상태로 전환 ] \n  * @param {*} stream_id(필수), topic_name(필수)\n  * @ex) markTopicMsgAsRead(48, \"stream events\")\n  */\n  async markTopicMsgAsRead(stream_id, topic_name){\n    const z = await this.z;\n    const params = {\n      stream_id: stream_id,\n      topic_name: topic_name \n    }\n    return z.messages.read.topicAll(params);\n  }\n\n /**\n  * [ 메시지 읽음 확인 ] \n  * @param {*} message_id (필수)\n  * @ex) getMsgReceipts({message_id: 479}) || getMsgReceipts(479)\n  */\n  async getMsgReceipts(message_id){\n    const z = await this.z;\n    const params = {\n      message_id: message_id,\n    }\n    return z.messages.read.receipts(params);\n  }\n\n\n  \n  /* -------------------\n  *     user 관련 \n  * -------------------- */\n /**\n  *  [ 전체 유저 조회 ]\n  * @param {*} client_gravatar(필수) (default = false)\n  */\n  async getAllUsers(client_gravatar) {\n    const z = await this.z;\n    const params = {\n      client_gravatar: client_gravatar // false로 설정시 avatar_url이 null이 아님.\n    }\n    return z.users.retrieve(params);\n  }\n\n /**\n  * [ 내 정보 조회 ]\n  * @ex) getOwnUser()\n  */\n  async getOwnUser() {\n    const z = await this.z;\n    return z.users.me.getProfile();\n  }\n\n /**\n  * [ 유저 id로 한 명 조회 ]\n  * @param {*} user_id (필수)\n  * @ex) getAUserById(23)\n  */\n  async getAUserById(user_id) {\n    const z = await this.z;\n    const params = {\n      user_id: user_id,\n      client_gravatar: false\n    }\n    return z.users.other.getUserById(params);\n  }\n\n /**\n  * [ 유저 email로 한 명 조회 ]\n  * @param {*} email (필수)\n  * @ex) getAUserByEmail(\"test002@cherrycorp.io\")\n  */\n  async getAUserByEmail(email) {\n    const z = await this.z;\n    const params = {\n      email: email,\n      client_gravatar: false\n    }\n    return z.users.other.getUserByEmail(params);\n  }\n\n /**\n  * [ 유저 정보 업데이트 ]\n  * @param {*} param (JSON형식) user_id(필수), role, full_name\n  * @ex) updateUser(29)\n  * administrator만 사용 가능한 기능\n  */\n  async updateUser(param) {\n    const z = await this.z;\n    const send_param = new Object();\n    const key_arr = [];\n    let keys = Object.keys(param);\n    for (let i = 0; i < keys.length; i++) {\n    \tlet key = keys[i];\n      key_arr.push(key);\n    }\n\n    if(key_arr.includes(\"user_id\")){\n      send_param.user_id = param[\"user_id\"];\n    } \n    if(key_arr.includes(\"role\")){\n      send_param.role = param[\"role\"];\n    } \n    if(key_arr.includes(\"full_name\")){\n      send_param.full_name = param[\"full_name\"];\n    } \n\n    return z.users.update(send_param);\n  }\n\n /**\n  * [ 내 상태 업데이트 ]\n  * @param {*} param(JSON형식) status_text(필수), emoji_name(필수)\n  * @ex) updateMyStatus(param)\n  */\n  async updateMyStatus(param) {\n    const z = await this.z;\n    const params = {\n      status_text: param.status_text, // 프로필 하단에 글씨가 써짐\n      // away: false, // 이 파라미터를 추가하면 에러가 남\n      emoji_name: param.emoji_name, // 닉네임 옆에 이모지 추가됨\n      // emoji_code: \"1f697\", // 이모지 관련\n      // reaction_type: \"unicode_emoji\", // 닉이모지 관련\n    }\n    return z.users.me.status(params);\n  }\n\n /**\n  * [ 유저 생성 ]\n  * @param {*} param (JSON형식) email(필수), password(필수), full_name(필수)\n  * administrator만 사용 가능한 기능\n  */\n  async createUser(param) {\n    const z = await this.z;\n    const params = {\n      email: param.email,\n      password: param.password,\n      full_name: param.full_name,\n    }\n    return z.users.create(params);\n  }\n\n /**\n  * [ 유저 활성화 ]\n  * @param {*} user_id (필수)\n  * @ex) deactivateUser(32)\n  * administrator만 사용 가능한 기능\n  */\n  async reactivateUser(user_id) {\n    const z = await this.z;\n    const params = {\n      user_id: user_id\n    }\n    return z.users.other.reactivate(params);\n  }\n\n /**\n  * [ 유저 비활성화 ]\n  * @param {*} user_id(필수), (deactivation_notification_comment : 비활성화 알림 여부)\n  * @ex) deactivateUser(32)\n  * administrator만 사용 가능한 기능\n  */\n  async deactivateUser(user_id) {\n    const z = await this.z;\n    const params = {\n      user_id: user_id,\n      // deactivation_notification_comment: \"Farewell!\\n\" // 확인가능한 결과 없음\n    }\n    return z.users.other.deactivate(params);\n  }\n\n /**\n  * [ 타이핑(\"입력중\") 알림 ] DM일 때\n  * @param {*} param(JSON형식) op(start/stop)(필수), to(private==user_ids)(필수), type = \"private\"이 디폴트값으로 들어감\n  * @ex) getTypingStatus(param)\n  * \"to\"에 입력하지 않은 다른 사용자들도 서로 dm일 때는 작성중이 뜸. stream 에서 입력중이 뜨지 않음.\n  */\n  async getTypingStatusPm(param) {\n    const z = await this.z;\n    const params = {\n      op: param.op,\n      to: param.to,\n    }\n    return z.users.typing(params);\n  }\n\n /**\n  * [ 타이핑(\"입력중\") 알림 ] 스트림일 때\n  * @param {*} param(JSON형식) op(start/stop)(필수), to(stream_id)(필수), topic(필수)\n  * @ex) getTypingStatusStream(param)\n  */\n  async getTypingStatusStream(param) {\n    const z = await this.z;\n    const params = {\n      op: param.op,\n      to: param.to,\n      type: \"stream\",\n      topic: param.topic\n    }\n    return z.users.typing(params);\n  }\n\n /**\n  * [ 접속중 조회 ]\n  * @params : user_id || user_email(택1 필수)\n  * @ex) getUserPresence(31)\n  */\n  async getUserPresence(user_id) {\n    const z = await this.z;\n    const params = {\n      user_id_or_email: user_id\n    }\n    return z.users.other.presence(params);\n  }\n\n /**\n  * [ 조직 내 전체 접속자 조회 ]\n  */\n  async getAllUserPresence() {\n    const z = await this.z;\n    return z.users.other.allPresence();\n  }\n  \n /**\n  * [ 전체 첨부파일 조회 ]\n  */\n  async getAttachments() {\n    const z = await this.z;\n    return z.users.attachments.retrieve();\n  }\n\n /**\n  * [ 첨부파일 삭제 ]\n  * @param {*} attachment_id (필수)\n  * @ex) deleteAttachment(32)\n  * 삭제 실행되지만 화면상으로는 완벽하게 사라지지 않음\n  */\n  async deleteAttachment(attachment_id) {\n    const z = await this.z;\n    const params = {\n      attachment_id: attachment_id\n    }\n    return z.users.attachments.delete(params);\n  }\n\n /**\n  * [ 환경 설정 ] noti && display 관련 세팅. \n  * (TODO) 파라미터를 선택가능하도록 변경\n  * @param {*} param (JSON형식) emojiset(필수), full_name, color_scheme(필수), enable_offline_push_notifications(필수), \n  *                             enable_online_push_notifications(필수), enable_stream_email_notifications(필수)\n  * @ex) updateSettings(param)\n  */\n  async updateSettings(param) {\n    const z = await this.z;\n    const params = {\n      // emojiset: param.emojiset,\n      // full_name: param.full_name,\n      color_scheme: param.color_scheme,\n      // enable_offline_push_notifications: param.enable_offline_push_notifications,\n      // enable_online_push_notifications: param.enable_online_push_notifications,\n      // enable_stream_email_notifications: param.enable_stream_email_notifications,\n    }\n    return z.users.settings.retrieve(params);\n  }\n\n /**\n  * [ 전체 그룹 조회 ] \n  */\n  async getUserGroups(){\n    const z = await this.z;\n    return z.users.group.retrieve();\n  }\n\n /**\n  * [ 그룹 생성 ] \n  * @param {*} name(필수), description(필수), members(필수)\n  * @ex) createUserGroup(\"HR\", \"인사팀\", [23, 22, 31])\n  */\n  async createUserGroup(name, description, members){\n    const z = await this.z;\n    const params = {\n      name: name,\n      description: description,\n      members: members,\n    }\n    return z.users.group.create(params);\n  }\n\n /**\n  * [ 그룹 업데이트 ] \n  * @param {*} user_group_id(필수), name(새 이름)(필수), description(새 설명)(필수)\n  * @ex) updateUserGroup(59, \"HR2\", \"인사2팀\")\n  */\n  async updateUserGroup(user_group_id, name, description){\n    const z = await this.z;\n    const params = {\n      user_group_id: user_group_id,\n      name: name,\n      description: description\n    }\n    return z.users.group.update(params);\n  }\n\n /**\n  * [ 그룹 삭제 ] \n  * @param {*} user_group_id (필수)\n  * @ex) deleteUserGroup(59)\n  */\n  async deleteUserGroup(user_group_id){\n    const z = await this.z;\n    const params = {\n      user_group_id: user_group_id,\n    }\n    return z.users.group.delete(params);\n  }\n\n /**\n  * [ 그룹 유저 추가/삭제 ] \n  * @param {*} param(JSON형식) user_group_id(필수), delete_user_ids(필수), add_user_ids(필수)\n  * @ex) updateUserGroupMembers(58)\n  */\n  async updateUserGroupMembers(param){\n    const z = await this.z;\n    const params = {\n      user_group_id: param.user_group_id,\n      delete: param.delete_user_ids,\n      add: param.add_user_ids\n    }\n    return z.users.group.updateMembers(params);\n  }\n\n /**\n  *  [ 그룹 유저 상태 조회 ] \n  * @param {*} user_group_id (필수), user_id (필수)\n  * @param {*} user_id \n  * @ex) getUserGroupMemberStatus(58, 23)\n  */\n  async getUserGroupMemberStatus(user_group_id, user_id){\n    const z = await this.z;\n    const params = {\n      user_group_id: user_group_id,\n      user_id: user_id,\n      // direct_member_only : direct_member_only \n    }\n    return z.users.group.status(params);\n  }\n\n /**\n  * [ 그룹 id로 유저 목록 조회 ] \n  * @param {*} user_group_id (필수)\n  * @ex) getUserGroupById(58)\n  */\n  async getUserGroupById(user_group_id){\n    const z = await this.z;\n    const params = {\n      user_group_id: user_group_id,\n      // direct_member_only : direct_member_only \n    }\n    return z.users.group.getUserGroupById(params);\n  }\n\n /**\n  * [ 사용자 음소거 ] \n  * @param {*} muted_user_id (필수)\n  * @ex) muteAUser(23)\n  * 음소거된 사용자가 보낸 모든 메시지 읽음 표시, 푸시 알림 지워짐, dm도 안 옴.\n  */\n  async muteAUser(muted_user_id){\n    const z = await this.z;\n    const params = {\n      muted_user_id: muted_user_id,\n    }\n    return z.users.other.muted(params);\n  }\n\n /**\n  * [ 사용자 음소거 해제 ] \n  * @param {*} muted_user_id (필수)\n  * @ex) unmuteAUser(23)\n  */\n  async unmuteAUser(muted_user_id){\n    const z = await this.z;\n    const params = {\n      muted_user_id: muted_user_id,\n    }\n    return z.users.other.unmuted(params);\n  }\n\n /**\n  * [ 키워드 알림 단어 조회 ] \n  */\n  async getAllAlertWords(){\n    const z = await this.z;\n    return z.users.me.alertWords.retrieve();\n  }\n\n /**\n  * [ 키워드 알림 단어 추가 ] \n  * @param {*} param(JSON형식) alertWords(필수)\n  * @ex) addAlertWords([\"foo\", \"bar\"])\n  */\n  async addAlertWords(param){\n    const z = await this.z;\n    const params = {\n      alert_words: param.alertWords,\n    }\n    return z.users.me.alertWords.add(params);\n  }\n\n /**\n  * [ 키워드 알림 단어 제거 ]\n  * @param {*} param (JSON형식) alertWords(필수)\n  * @ex) let param = { alertWords: [\"멍청이2\"] }\n  */\n  async deleteAlertWords(param){\n    const z = await this.z;\n    const params = {\n      alert_words: JSON.stringify(param.alertWords),\n    }\n    return z.users.me.alertWords.delete(params);\n  }\n\n\n\n}\n\nclass Urls {\n  constructor(message) {\n    this.message = message;\n  }\n  stream_id_to_slug(stream_id, maybe_get_stream_name) {\n    let name = maybe_get_stream_name || \"unknown\";\n    name = name.replace(/ /g, \"-\");\n    return stream_id + \"-\" + name;\n  }\n  encode_stream_id(stream_id, maybe_get_stream_name) {\n    const u = new Urls();\n    const slug = u.stream_id_to_slug(stream_id, maybe_get_stream_name);\n    return u.encodeHashComponent(slug);\n  }\n  set_by_stream_topic_url(stream_id, topic, maybe_get_stream_name) {\n    const u = new Urls();\n    return (\n        \"#narrow/stream/\" +\n        u.encode_stream_id(stream_id, maybe_get_stream_name) +\n        \"/topic/\" +\n        u.encodeHashComponent(topic)\n    );\n  }\n  sort_numerically(user_ids) {\n    user_ids.sort((a, b) => a - b);\n    return user_ids;\n  }\n  all_user_ids_in_pm(message) {\n    const u = new Urls();\n    if (message.type !== \"private\") {\n        return undefined;\n    }\n    if (message.display_recipient.length === 0) {\n        blueslip.error(\"Empty recipient list in message\");\n        return undefined;\n    }\n    let user_ids = message.display_recipient.map((recip) => recip.id);\n    user_ids = u.sort_numerically(user_ids);\n    return user_ids;\n  }\n  by_stream_topic_url(stream_id, topic, stream_name) {\n    const u = new Urls();\n    let maybe_get_stream_name = stream_name;\n    return u.set_by_stream_topic_url(stream_id, topic, maybe_get_stream_name);\n  }\n  pm_perma_link(message) {\n    const u = new Urls();\n    const user_ids = all_user_ids_in_pm(message);\n    if (!user_ids) {\n        return undefined;\n    }\n    let suffix;\n    if (user_ids.length >= 3) {\n        suffix = \"group\";\n    } else {\n        suffix = \"pm\";\n    }\n    const slug = user_ids.join(\",\") + \"-\" + suffix;\n    const uri = \"#narrow/pm-with/\" + slug;\n    return uri;\n  }\n  encodeHashComponent(str) {\n    return encodeURIComponent(str).replace(/[%().]/g, (matched) => hashReplacements.get(matched));\n  }\n  by_conversation_and_time_url(message) {\n    const u = new Urls();\n    const absolute_url =\n        window.location.protocol +\n        \"//\" +\n        window.location.host +\n        \"/\" +\n        window.location.pathname.split(\"/\")[1];\n    const suffix = \"/near/\" + u.encodeHashComponent(message.id);\n    if (message.type === \"stream\") {\n        return absolute_url + u.by_stream_topic_url(message.stream_id, message.subject, message.display_recipient) + suffix;\n    }\n    return absolute_url + u.pm_perma_link(message) + suffix;\n  }\n}\n\n// eslint-disable-next-line no-unused-vars\nfunction localTest() {\n  // 실행 명령어 : node zulip_cherry_main.js\n  process.env.NODE_TLS_REJECT_UNAUTHORIZED = 0;\n  // eslint-disable-next-line no-unused-vars\n  const cz = new CZulip(\"1000000000000002597@dev.cworld.cherry\",\"jHziQ89YjPSUcOsLnQSZuxB38XuylOUO\", \"https://dev-zulip.letscherry.io\");\n  // const cz = new CZulip(\"zulip@cherrycorp.io\",\"H8JKDAcojlSxoGIGrSo5uqPD4cKGvYvF\", \"https://dev-zulip.letscherry.io\");\n  // cz.getUserGroups().then((m)=> {console.log(m);});\n  // cz.updateUserGroup(15, \"그룹테스트2\", \"그룹테스트 patch test\").then((m)=> {console.log(m);});\n\n  // const params = {\n  //   color_scheme: 1\n  // }\n  // cz.updateSettings(params).then((m)=> {console.log(m);});\n\n  // const params = {\n  //   user_id: 633,\n  //   role: 400\n  // }\n  // cz.updateUser(params).then((m)=> {console.log(m);});\n\n  // cz.muteUnmuteTopic(\"bulkTest\", \"postmantest\", \"remove\").then((m)=> {console.log(m);});\n\n  // const params = {\n  //   stream_id: 238,\n  //   description: \"fetch test\"\n  // }\n  // cz.updateStream(params).then((m)=> {console.log(m);});\n  // cz.getOneStreamId(\"bulkTest\").then((m)=> {console.log(m);});\n}\n\n// localTest();\n\n\nmodule.exports = {\n  // eslint-disable-next-line object-shorthand\n  CZulip: CZulip,\n  Urls: Urls,\n};\n\n//# sourceURL=webpack://cw/./browser/zulip_cherry_main.js?");

/***/ }),

/***/ "./lib/api.js":
/*!********************!*\
  !*** ./lib/api.js ***!
  \********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nvar _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\"));\nvar _slicedToArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ \"./node_modules/@babel/runtime/helpers/slicedToArray.js\"));\nvar _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/asyncToGenerator.js\"));\n/* eslint-disable */\nvar helper = __webpack_require__(/*! ./helper */ \"./lib/helper.js\");\n// const https = require('https');  0104 ssl 에러 테스트 -> 효과없어서 주석처리\nfunction api(_x, _x2, _x3, _x4) {\n  return _api.apply(this, arguments);\n}\nfunction _api() {\n  _api = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee(baseUrl, config, method, params) {\n    var url, auth, authHeader, options, response, message, error;\n    return _regenerator[\"default\"].wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            url = new URL(baseUrl);\n            auth = Buffer.from(\"\".concat(config.username, \":\").concat(config.apiKey)).toString('base64');\n            authHeader = \"Basic \".concat(auth);\n            options = {\n              method: method,\n              headers: {\n                Authorization: authHeader\n              },\n              mode: 'cors'\n            }; // const httpsAgent = new https.Agent({\n            //   rejectUnauthorized: false,\n            // });\n            /**\n             * 23.06.08 수정사항 suyeoun.kim\n             * - editMsg() 호출시 종종 글자수가 인코딩되어 searchParams으로 넘어가서 fetch 에러가 발생하였음\n             *  이를 해결하기 위해 POST 방식과 동일하게 FormData를 사용하는 것으로 변경하니 에러가 발생하지 않음\n             */\n            if (method === 'POST' || method === 'PATCH') {\n              options.body = new helper.FormData();\n              Object.keys(params).forEach(function (key) {\n                var data = params[key];\n                if (Array.isArray(data)) {\n                  data = JSON.stringify(data);\n                }\n                options.body.append(key, data);\n                // options.agent = httpsAgent;\n              });\n            } else if (params) {\n              Object.entries(params).forEach(function (_ref) {\n                var _ref2 = (0, _slicedToArray2[\"default\"])(_ref, 2),\n                  key = _ref2[0],\n                  value = _ref2[1];\n                url.searchParams.append(key, value);\n              });\n            }\n            _context.next = 7;\n            return helper.fetch(url.href, options);\n          case 7:\n            response = _context.sent;\n            _context.prev = 8;\n            return _context.abrupt(\"return\", response.json());\n          case 12:\n            _context.prev = 12;\n            _context.t0 = _context[\"catch\"](8);\n            if (!(_context.t0 instanceof SyntaxError)) {\n              _context.next = 20;\n              break;\n            }\n            // We probably got a non-JSON response from the server.\n            // We should inform the user of the same.\n            message = 'Server Returned a non-JSON response.';\n            if (response.status === 404) {\n              message += \" Maybe endpoint: \".concat(method, \" \").concat(response.url.replace(config.apiURL, ''), \" doesn't exist.\");\n            } else {\n              message += ' Please check the API documentation.';\n            }\n            error = new Error(message);\n            error.res = response;\n            throw error;\n          case 20:\n            throw _context.t0;\n          case 21:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[8, 12]]);\n  }));\n  return _api.apply(this, arguments);\n}\nmodule.exports = api;\n\n//# sourceURL=webpack://cw/./lib/api.js?");

/***/ }),

/***/ "./lib/events_wrapper.js":
/*!*******************************!*\
  !*** ./lib/events_wrapper.js ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nvar _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\"));\nvar _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/asyncToGenerator.js\"));\nvar queues = __webpack_require__(/*! ./resources/queues */ \"./lib/resources/queues.js\");\nvar events = __webpack_require__(/*! ./resources/events */ \"./lib/resources/events.js\");\nfunction sleep(ms) {\n  // TODO add jitter.\n  return new Promise(function (resolve) {\n    return setTimeout(resolve, ms);\n  });\n}\nfunction eventsWrapper(config) {\n  var z = {\n    queues: queues(config),\n    events: events(config)\n  };\n  function logError(error) {\n    console.log('zulip-js: Error while communicating with server:', error); // eslint-disable-line no-console\n  }\n  function registerQueue() {\n    return _registerQueue.apply(this, arguments);\n  }\n  function _registerQueue() {\n    _registerQueue = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee() {\n      var eventTypes,\n        res,\n        params,\n        _args = arguments;\n      return _regenerator[\"default\"].wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              eventTypes = _args.length > 0 && _args[0] !== undefined ? _args[0] : null;\n            case 1:\n              if (false) {}\n              _context.prev = 2;\n              params = {\n                eventTypes: eventTypes\n              };\n              _context.next = 6;\n              return z.queues.register(params);\n            case 6:\n              res = _context.sent;\n              if (!(res.result === 'error')) {\n                _context.next = 13;\n                break;\n              }\n              logError(res.msg);\n              _context.next = 11;\n              return sleep(1000);\n            case 11:\n              _context.next = 14;\n              break;\n            case 13:\n              return _context.abrupt(\"return\", {\n                queueId: res.queue_id,\n                lastEventId: res.last_event_id\n              });\n            case 14:\n              _context.next = 19;\n              break;\n            case 16:\n              _context.prev = 16;\n              _context.t0 = _context[\"catch\"](2);\n              logError(_context.t0);\n            case 19:\n              _context.next = 1;\n              break;\n            case 21:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[2, 16]]);\n    }));\n    return _registerQueue.apply(this, arguments);\n  }\n  function callOnEachEvent(_x) {\n    return _callOnEachEvent.apply(this, arguments);\n  }\n  function _callOnEachEvent() {\n    _callOnEachEvent = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee2(callback) {\n      var eventTypes,\n        queueId,\n        lastEventId,\n        handleEvent,\n        queueData,\n        res,\n        _args2 = arguments;\n      return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              eventTypes = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : null;\n              queueId = null;\n              lastEventId = -1;\n              handleEvent = function handleEvent(event) {\n                lastEventId = Math.max(lastEventId, event.id);\n                callback(event);\n              }; // eslint-disable-next-line no-constant-condition\n            case 4:\n              if (false) {}\n              if (queueId) {\n                _context2.next = 11;\n                break;\n              }\n              _context2.next = 8;\n              return registerQueue(eventTypes);\n            case 8:\n              queueData = _context2.sent;\n              // eslint-disable-line no-await-in-loop\n              queueId = queueData.queueId;\n              lastEventId = queueData.lastEventId;\n            case 11:\n              _context2.prev = 11;\n              _context2.next = 14;\n              return z.events.retrieve({\n                queue_id: queueId,\n                last_event_id: lastEventId,\n                dont_block: false\n              });\n            case 14:\n              res = _context2.sent;\n              if (res.events) {\n                res.events.forEach(handleEvent);\n              }\n              _context2.next = 21;\n              break;\n            case 18:\n              _context2.prev = 18;\n              _context2.t0 = _context2[\"catch\"](11);\n              logError(_context2.t0);\n            case 21:\n              _context2.next = 23;\n              return sleep(1000);\n            case 23:\n              _context2.next = 4;\n              break;\n            case 25:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[11, 18]]);\n    }));\n    return _callOnEachEvent.apply(this, arguments);\n  }\n  return callOnEachEvent;\n}\nmodule.exports = eventsWrapper;\n\n//# sourceURL=webpack://cw/./lib/events_wrapper.js?");

/***/ }),

/***/ "./lib/helper.js":
/*!***********************!*\
  !*** ./lib/helper.js ***!
  \***********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar fetch = __webpack_require__(/*! isomorphic-fetch */ \"./node_modules/isomorphic-fetch/fetch-npm-browserify.js\");\nvar FormData = __webpack_require__(/*! isomorphic-form-data */ \"./node_modules/isomorphic-form-data/lib/browser.js\");\nmodule.exports = {\n  fetch: fetch,\n  FormData: FormData\n};\n\n//# sourceURL=webpack://cw/./lib/helper.js?");

/***/ }),

/***/ "./lib/index.js":
/*!**********************!*\
  !*** ./lib/index.js ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nvar _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\"));\nvar _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/asyncToGenerator.js\"));\nvar _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\"));\nvar _zuliprc = _interopRequireDefault(__webpack_require__(/*! ./zuliprc */ \"./lib/zuliprc.js\"));\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar api = __webpack_require__(/*! ./api */ \"./lib/api.js\");\nvar accounts = __webpack_require__(/*! ./resources/accounts */ \"./lib/resources/accounts.js\");\nvar streams = __webpack_require__(/*! ./resources/streams */ \"./lib/resources/streams.js\");\nvar messages = __webpack_require__(/*! ./resources/messages */ \"./lib/resources/messages.js\");\nvar queues = __webpack_require__(/*! ./resources/queues */ \"./lib/resources/queues.js\");\nvar events = __webpack_require__(/*! ./resources/events */ \"./lib/resources/events.js\");\nvar users = __webpack_require__(/*! ./resources/users */ \"./lib/resources/users.js\");\nvar emojis = __webpack_require__(/*! ./resources/emojis */ \"./lib/resources/emojis.js\");\nvar typing = __webpack_require__(/*! ./resources/typing */ \"./lib/resources/typing.js\");\nvar reactions = __webpack_require__(/*! ./resources/reactions */ \"./lib/resources/reactions.js\");\nvar server = __webpack_require__(/*! ./resources/server */ \"./lib/resources/server.js\");\nvar filters = __webpack_require__(/*! ./resources/filters */ \"./lib/resources/filters.js\");\nvar eventsWapper = __webpack_require__(/*! ./events_wrapper */ \"./lib/events_wrapper.js\");\nfunction getCallEndpoint(config) {\n  return function callEndpoint(endpoint) {\n    var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'GET';\n    var params = arguments.length > 2 ? arguments[2] : undefined;\n    var myConfig = _objectSpread({}, config);\n    var finalendpoint = endpoint;\n    if (!endpoint.startsWith('/')) {\n      finalendpoint = \"/\".concat(endpoint);\n    }\n    var url = myConfig.apiURL + finalendpoint;\n    return api(url, myConfig, method, params);\n  };\n}\nfunction resources(config) {\n  return {\n    config: config,\n    callEndpoint: getCallEndpoint(config),\n    accounts: accounts(config),\n    streams: streams(config),\n    messages: messages(config),\n    queues: queues(config),\n    events: events(config),\n    users: users(config),\n    emojis: emojis(config),\n    typing: typing(config),\n    reactions: reactions(config),\n    server: server(config),\n    filters: filters(config),\n    callOnEachEvent: eventsWapper(config)\n  };\n}\nfunction zulip(_x) {\n  return _zulip.apply(this, arguments);\n}\nfunction _zulip() {\n  _zulip = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee(initialConfig) {\n    var config, res;\n    return _regenerator[\"default\"].wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!initialConfig.zuliprc) {\n              _context.next = 6;\n              break;\n            }\n            _context.t0 = resources;\n            _context.next = 4;\n            return (0, _zuliprc[\"default\"])(initialConfig.zuliprc);\n          case 4:\n            _context.t1 = _context.sent;\n            return _context.abrupt(\"return\", (0, _context.t0)(_context.t1));\n          case 6:\n            config = initialConfig;\n            if (config.realm.endsWith('/api')) {\n              config.apiURL = \"\".concat(config.realm, \"/v1\");\n            } else {\n              config.apiURL = \"\".concat(config.realm, \"/api/v1\");\n            }\n            if (config.apiKey) {\n              _context.next = 13;\n              break;\n            }\n            _context.next = 11;\n            return accounts(config).retrieve();\n          case 11:\n            res = _context.sent;\n            config.apiKey = res.api_key;\n          case 13:\n            return _context.abrupt(\"return\", resources(config));\n          case 14:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _zulip.apply(this, arguments);\n}\nmodule.exports = zulip;\n\n//# sourceURL=webpack://cw/./lib/index.js?");

/***/ }),

/***/ "./lib/resources/accounts.js":
/*!***********************************!*\
  !*** ./lib/resources/accounts.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nvar _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\"));\nvar _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/asyncToGenerator.js\"));\nvar helper = __webpack_require__(/*! ../helper */ \"./lib/helper.js\");\nfunction accounts(config) {\n  return {\n    retrieve: function () {\n      var _retrieve = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee() {\n        var url, form, res;\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                url = \"\".concat(config.apiURL, \"/fetch_api_key\");\n                form = new helper.FormData();\n                form.append('username', config.username);\n                form.append('password', config.password);\n                _context.next = 6;\n                return helper.fetch(url, {\n                  method: 'POST',\n                  body: form\n                });\n              case 6:\n                res = _context.sent;\n                return _context.abrupt(\"return\", res.json());\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n      function retrieve() {\n        return _retrieve.apply(this, arguments);\n      }\n      return retrieve;\n    }()\n  };\n}\nmodule.exports = accounts;\n\n//# sourceURL=webpack://cw/./lib/resources/accounts.js?");

/***/ }),

/***/ "./lib/resources/emojis.js":
/*!*********************************!*\
  !*** ./lib/resources/emojis.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar api = __webpack_require__(/*! ../api */ \"./lib/api.js\");\nfunction emojis(config) {\n  return {\n    retrieve: function retrieve(params) {\n      var url = \"\".concat(config.apiURL, \"/realm/emoji\");\n      return api(url, config, 'GET', params);\n    },\n    set: function set(params) {\n      var url = \"\".concat(config.apiURL, \"/realm/emoji/\").concat(params.emoji_name);\n      return api(url, config, 'POST', params);\n    }\n  };\n}\nmodule.exports = emojis;\n\n//# sourceURL=webpack://cw/./lib/resources/emojis.js?");

/***/ }),

/***/ "./lib/resources/events.js":
/*!*********************************!*\
  !*** ./lib/resources/events.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar api = __webpack_require__(/*! ../api */ \"./lib/api.js\");\nfunction events(config) {\n  return {\n    retrieve: function retrieve(params) {\n      var url = \"\".concat(config.apiURL, \"/events\");\n      return api(url, config, 'GET', params);\n    }\n  };\n}\nmodule.exports = events;\n\n//# sourceURL=webpack://cw/./lib/resources/events.js?");

/***/ }),

/***/ "./lib/resources/filters.js":
/*!**********************************!*\
  !*** ./lib/resources/filters.js ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar api = __webpack_require__(/*! ../api */ \"./lib/api.js\");\nfunction filters(config) {\n  return {\n    retrieve: function retrieve(params) {\n      var url = \"\".concat(config.apiURL, \"/realm/filters\");\n      return api(url, config, 'GET', params);\n    }\n  };\n}\nmodule.exports = filters;\n\n//# sourceURL=webpack://cw/./lib/resources/filters.js?");

/***/ }),

/***/ "./lib/resources/messages.js":
/*!***********************************!*\
  !*** ./lib/resources/messages.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nvar _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\"));\nvar _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/asyncToGenerator.js\"));\nvar _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\"));\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n/* eslint-disable */\nvar api = __webpack_require__(/*! ../api */ \"./lib/api.js\");\nfunction messages(config) {\n  var baseURL = \"\".concat(config.apiURL, \"/messages\");\n  var flagsURL = \"\".concat(baseURL, \"/flags\");\n  return {\n    retrieve: function retrieve(initialParams) {\n      // 메시지 정보 조회\n      var url = \"\".concat(config.apiURL, \"/messages\");\n      var params = _objectSpread({}, initialParams);\n      if (params.narrow) {\n        params.narrow = JSON.stringify(params.narrow);\n      }\n      return api(url, config, 'GET', params);\n    },\n    send: function () {\n      var _send = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee(params) {\n        var url;\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                // 스트림/private에 메시지 보내기\n                url = \"\".concat(config.apiURL, \"/messages\");\n                return _context.abrupt(\"return\", api(url, config, 'POST', params));\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n      function send(_x) {\n        return _send.apply(this, arguments);\n      }\n      return send;\n    }(),\n    render: function render(initialParams) {\n      // 메시지 랜더링\n      var url = \"\".concat(config.apiURL, \"/messages/render\");\n      var params = _objectSpread({}, initialParams);\n      if (typeof initialParams === 'string') {\n        params = {\n          content: initialParams\n        };\n      }\n      return api(url, config, 'POST', params);\n    },\n    update: function update(params) {\n      // 메시지 수정\n      var url = \"\".concat(config.apiURL, \"/messages/\").concat(params.message_id);\n      return api(url, config, 'PATCH', params);\n    },\n    flags: {\n      add: function add(initialParams) {\n        // 플래그 업데이트\n        // params.flag can be one of 'read', 'starred', 'mentioned',\n        // 'wildcard_mentioned', 'has_alert_word', 'historical',\n        var params = _objectSpread({}, initialParams);\n        params.op = 'add';\n        if (params.messages) {\n          params.messages = JSON.stringify(params.messages);\n        }\n        return api(flagsURL, config, 'POST', params);\n      },\n      remove: function remove(initialParams) {\n        // 플래그 삭제\n        // params.flag can be one of 'read', 'starred', 'mentioned',\n        // 'wildcard_mentioned', 'has_alert_word', 'historical',\n        var params = _objectSpread({}, initialParams);\n        params.op = 'remove';\n        if (params.messages) {\n          params.messages = JSON.stringify(params.messages);\n        }\n        return api(flagsURL, config, 'POST', params);\n      }\n    },\n    file: {\n      upload: function upload(params) {\n        // 스트림에 파일 업로드\n        var url = \"\".concat(config.apiURL, \"/user_uploads\");\n        return api(url, config, 'POST', params);\n      }\n    },\n    emoji: {\n      add: function add(params) {\n        // 메시지에 이모지 추가\n        var url = \"\".concat(config.apiURL, \"/messages/\").concat(params.message_id, \"/reactions\");\n        return api(url, config, 'POST', params);\n      },\n      remove: function remove(params) {\n        // 메시지에 이모지 삭제\n        var url = \"\".concat(config.apiURL, \"/messages/\").concat(params.message_id, \"/reactions\");\n        return api(url, config, 'DELETE', params);\n      }\n    },\n    narrow: {\n      match: function match(params) {\n        // narrow 기준이 메시지와 일치하는지 확인\n        var url = \"\".concat(config.apiURL, \"/messages/matches_narrow\");\n        return api(url, config, 'GET', params);\n      }\n    },\n    getById: function getById(params) {\n      // 단일 메시지 조회\n      var url = \"\".concat(config.apiURL, \"/messages/\").concat(params.message_id);\n      return api(url, config, 'GET', params);\n    },\n    getHistoryById: function getHistoryById(params) {\n      // 메시지 수정 내역 조회\n      var url = \"\".concat(config.apiURL, \"/messages/\").concat(params.message_id, \"/history\");\n      return api(url, config, 'GET', params);\n    },\n    deleteById: function deleteById(params) {\n      // 메시지 삭제\n      var url = \"\".concat(config.apiURL, \"/messages/\").concat(params.message_id);\n      return api(url, config, 'DELETE', params);\n    },\n    read: {\n      readAll: function readAll() {\n        // 모든 글 읽음 상태로 전환\n        var url = \"\".concat(config.apiURL, \"/mark_all_as_read\");\n        return api(url, config, 'POST');\n      },\n      streamAll: function streamAll(params) {\n        // 스트림 글 읽음 상태로 전환\n        var url = \"\".concat(config.apiURL, \"/mark_stream_as_read\");\n        return api(url, config, 'POST', params);\n      },\n      topicAll: function topicAll(params) {\n        // 토픽 글 읽음 상태로 전환\n        var url = \"\".concat(config.apiURL, \"/mark_topic_as_read\");\n        return api(url, config, 'POST', params);\n      },\n      receipts: function receipts(params) {\n        // 메시지 읽음 확인\n        var url = \"\".concat(config.apiURL, \"/messages/\").concat(params.message_id, \"/read_receipts\");\n        return api(url, config, 'GET', params);\n      }\n    }\n  };\n}\nmodule.exports = messages;\n\n//# sourceURL=webpack://cw/./lib/resources/messages.js?");

/***/ }),

/***/ "./lib/resources/queues.js":
/*!*********************************!*\
  !*** ./lib/resources/queues.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nvar _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\"));\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar api = __webpack_require__(/*! ../api */ \"./lib/api.js\");\nfunction queues(config) {\n  return {\n    register: function register(initialParams) {\n      var url = \"\".concat(config.apiURL, \"/register\");\n      var params = _objectSpread({}, initialParams);\n      if (params.event_types) {\n        params.event_types = JSON.stringify(params.event_types);\n      }\n      return api(url, config, 'POST', params);\n    },\n    deregister: function deregister(params) {\n      var url = \"\".concat(config.apiURL, \"/events\");\n      return api(url, config, 'DELETE', params);\n    }\n  };\n}\nmodule.exports = queues;\n\n//# sourceURL=webpack://cw/./lib/resources/queues.js?");

/***/ }),

/***/ "./lib/resources/reactions.js":
/*!************************************!*\
  !*** ./lib/resources/reactions.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nvar _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\"));\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar api = __webpack_require__(/*! ../api */ \"./lib/api.js\");\nfunction reactions(config) {\n  var url = function url(messageID) {\n    return \"\".concat(config.apiURL, \"/messages/\").concat(messageID, \"/reactions\");\n  };\n  var call = function call(method, initParams) {\n    var params = _objectSpread({}, initParams);\n    delete params.message_id;\n    return api(url(initParams.message_id), config, method, params);\n  };\n  return {\n    add: function add(params) {\n      return call('POST', params);\n    },\n    remove: function remove(params) {\n      return call('DELETE', params);\n    }\n  };\n}\nmodule.exports = reactions;\n\n//# sourceURL=webpack://cw/./lib/resources/reactions.js?");

/***/ }),

/***/ "./lib/resources/server.js":
/*!*********************************!*\
  !*** ./lib/resources/server.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar api = __webpack_require__(/*! ../api */ \"./lib/api.js\");\nfunction server(config) {\n  return {\n    settings: function settings(params) {\n      var url = \"\".concat(config.apiURL, \"/server_settings\");\n      return api(url, config, 'GET', params);\n    }\n  };\n}\nmodule.exports = server;\n\n//# sourceURL=webpack://cw/./lib/resources/server.js?");

/***/ }),

/***/ "./lib/resources/streams.js":
/*!**********************************!*\
  !*** ./lib/resources/streams.js ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nvar _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\"));\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n/* eslint-disable */\nvar api = __webpack_require__(/*! ../api */ \"./lib/api.js\");\nfunction streams(config) {\n  return {\n    retrieve: function retrieve(params) {\n      // 전체 스트림 조회\n      var url = \"\".concat(config.apiURL, \"/streams\");\n      return api(url, config, 'GET', params);\n    },\n    getStreamById: function getStreamById(params) {\n      // 스트림 id로 각 스트림 정보 조회\n      var url = \"\".concat(config.apiURL, \"/streams/\").concat(params.stream_id);\n      return api(url, config, 'GET', params);\n    },\n    getStreamId: function getStreamId(initialParams) {\n      // 스트림명으로 해당 스트림의 ID 조회\n      var url = \"\".concat(config.apiURL, \"/get_stream_id\");\n      var params = _objectSpread({}, initialParams);\n      if (typeof initialParams === 'string') {\n        params = {\n          stream: initialParams\n        };\n      }\n      return api(url, config, 'GET', params);\n    },\n    subscriptions: {\n      retrieve: function retrieve(params) {\n        // 나의 구독(공개/비공개된) 전체 스트림 조회\n        var param = _objectSpread({}, params);\n        var url = \"\".concat(config.apiURL, \"/users/me/subscriptions\");\n        return api(url, config, 'GET', params);\n      },\n      update: function update(params) {\n        // 스트림 업데이트\n        var param = _objectSpread({}, params);\n        var url = \"\".concat(config.apiURL, \"/streams/\").concat(param.stream_id);\n        return api(url, config, 'PATCH', params);\n      },\n      status: function status(params) {\n        // 유저의 스트림 구독 상태 조회\n        var param = _objectSpread({}, params);\n        var url = \"\".concat(config.apiURL, \"/users/\").concat(param.user_id, \"/subscriptions/\").concat(param.stream_id);\n        return api(url, config, 'GET', params);\n      },\n      allSubscribers: function allSubscribers(params) {\n        // 해당 스트림을 구독하는 구독자들 id 조회\n        var param = _objectSpread({}, params);\n        var url = \"\".concat(config.apiURL, \"/streams/\").concat(param.stream_id, \"/members\");\n        return api(url, config, 'GET', params);\n      }\n    },\n    topics: {\n      retrieve: function retrieve(params) {\n        // 해당 스트림에서 토픽 조회\n        var url = \"\".concat(config.apiURL, \"/users/me/\").concat(params.stream_id, \"/topics\");\n        return api(url, config, 'GET');\n      },\n      mutedTopics: function mutedTopics(params) {\n        // 토픽 뮤트/언뮤트\n        var url = \"\".concat(config.apiURL, \"/users/me/subscriptions/muted_topics\");\n        return api(url, config, 'PATCH', params);\n      },\n      \"delete\": function _delete(params) {\n        // 토픽 삭제\n        var url = \"\".concat(config.apiURL, \"/streams/\").concat(params.stream_id, \"/delete_topic\");\n        return api(url, config, 'POST', params);\n      }\n    },\n    deleteById: function deleteById(params) {\n      // 해당 스트림 삭제(아카이브)\n      var url = \"\".concat(config.apiURL, \"/streams/\").concat(params.stream_id);\n      return api(url, config, 'DELETE', params);\n    },\n    defaultStream: {\n      add: function add(params) {\n        // default stream 설정\n        var url = \"\".concat(config.apiURL, \"/default_streams\");\n        // params 인자 추가\n        return api(url, config, 'POST', params);\n      },\n      remove: function remove(params) {\n        // remove default stream 설정\n        var url = \"\".concat(config.apiURL, \"/default_streams\");\n        // params 인자 추가\n        return api(url, config, 'DELETE', params);\n      }\n    }\n  };\n}\nmodule.exports = streams;\n\n//# sourceURL=webpack://cw/./lib/resources/streams.js?");

/***/ }),

/***/ "./lib/resources/typing.js":
/*!*********************************!*\
  !*** ./lib/resources/typing.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nvar _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\"));\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar api = __webpack_require__(/*! ../api */ \"./lib/api.js\");\nfunction typing(config) {\n  return {\n    send: function send(initialParams) {\n      var url = \"\".concat(config.apiURL, \"/typing\");\n      var params = _objectSpread({}, initialParams);\n      if (params.to.length > 1) {\n        params.to = JSON.stringify(params.to);\n      }\n      return api(url, config, 'POST', params);\n    }\n  };\n}\nmodule.exports = typing;\n\n//# sourceURL=webpack://cw/./lib/resources/typing.js?");

/***/ }),

/***/ "./lib/resources/users.js":
/*!********************************!*\
  !*** ./lib/resources/users.js ***!
  \********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* eslint-disable */\nvar api = __webpack_require__(/*! ../api */ \"./lib/api.js\");\nfunction users(config) {\n  return {\n    retrieve: function retrieve(params) {\n      // 전체 유저 조회\n      var url = \"\".concat(config.apiURL, \"/users\");\n      return api(url, config, 'GET', params);\n    },\n    create: function create(params) {\n      // 유저 생성\n      var url = \"\".concat(config.apiURL, \"/users\");\n      return api(url, config, 'POST', params);\n    },\n    update: function update(params) {\n      // 유저 정보 업데이트\n      var url = \"\".concat(config.apiURL, \"/users/\").concat(params.user_id);\n      return api(url, config, 'PATCH', params);\n    },\n    me: {\n      pointer: {\n        retrieve: function retrieve(params) {\n          var url = \"\".concat(config.apiURL, \"/users/me/pointer\");\n          return api(url, config, 'GET', params);\n        },\n        update: function update(id) {\n          var url = \"\".concat(config.apiURL, \"/users/me/pointer\");\n          return api(url, config, 'POST', {\n            pointer: id\n          });\n        }\n      },\n      getProfile: function getProfile() {\n        // 내 정보 조회\n        var url = \"\".concat(config.apiURL, \"/users/me\");\n        return api(url, config, 'GET');\n      },\n      subscriptions: {\n        add: function add(params) {\n          // 나의 새 스트림 생성(create) 및 기존 스트림 구독\n          var url = \"\".concat(config.apiURL, \"/users/me/subscriptions\");\n          return api(url, config, 'POST', params);\n        },\n        remove: function remove(params) {\n          // 나의 스트림 구독 취소\n          var url = \"\".concat(config.apiURL, \"/users/me/subscriptions\");\n          return api(url, config, 'DELETE', params);\n        },\n        properties: function properties(params) {\n          // 스트림의 설정 변경\n          var url = \"\".concat(config.apiURL, \"/users/me/subscriptions/properties\");\n          return api(url, config, 'POST', params);\n        }\n      },\n      alertWords: {\n        retrieve: function retrieve(params) {\n          // 경고 단어 조회\n          var url = \"\".concat(config.apiURL, \"/users/me/alert_words\");\n          return api(url, config, 'GET', params);\n        },\n        add: function add(params) {\n          // 경고 단어 추가\n          var url = \"\".concat(config.apiURL, \"/users/me/alert_words\");\n          return api(url, config, 'POST', params);\n        },\n        \"delete\": function _delete(params) {\n          // 경고 단어 제거\n          var url = \"\".concat(config.apiURL, \"/users/me/alert_words\");\n          return api(url, config, 'DELETE', params);\n        }\n      },\n      status: function status(params) {\n        // 내 상태 업데이트\n        var url = \"\".concat(config.apiURL, \"/users/me/status\");\n        return api(url, config, 'POST', params);\n      },\n      deactivate: function deactivate(params) {\n        // 나 비활성화 (테스트 미완료)\n        var url = \"\".concat(config.apiURL, \"/users/me\");\n        return api(url, config, 'DELETE', params);\n      }\n    },\n    other: {\n      getUserById: function getUserById(params) {\n        // 유저 id로 한 명 조회\n        var url = \"\".concat(config.apiURL, \"/users/\").concat(params.user_id);\n        return api(url, config, 'GET', params);\n      },\n      getUserByEmail: function getUserByEmail(params) {\n        // 유저 email로 한 명 조회\n        var url = \"\".concat(config.apiURL, \"/users/\").concat(params.email);\n        return api(url, config, 'GET', params);\n      },\n      deactivate: function deactivate(params) {\n        // 유저 비활성화\n        var url = \"\".concat(config.apiURL, \"/users/\").concat(params.user_id);\n        return api(url, config, 'DELETE', params);\n      },\n      reactivate: function reactivate(params) {\n        // 유저 활성화\n        var url = \"\".concat(config.apiURL, \"/users/\").concat(params.user_id, \"/reactivate\");\n        return api(url, config, 'POST', params);\n      },\n      presence: function presence(params) {\n        // 접속중 조회\n        var url = \"\".concat(config.apiURL, \"/users/\").concat(params.user_id_or_email, \"/presence\");\n        return api(url, config, 'GET', params);\n      },\n      allPresence: function allPresence(params) {\n        // 조직 내 전체 접속중 조회\n        var url = \"\".concat(config.apiURL, \"/realm/presence\");\n        return api(url, config, 'GET', params);\n      },\n      muted: function muted(params) {\n        // 사용자 음소거\n        var url = \"\".concat(config.apiURL, \"/users/me/muted_users/\").concat(params.muted_user_id);\n        return api(url, config, 'POST', params);\n      },\n      unmuted: function unmuted(params) {\n        // 사용자 음소거 해제\n        var url = \"\".concat(config.apiURL, \"/users/me/muted_users/\").concat(params.muted_user_id);\n        return api(url, config, 'DELETE', params);\n      }\n    },\n    typing: function typing(params) {\n      // 타이핑(\"입력중\") 알림\n      var url = \"\".concat(config.apiURL, \"/typing\");\n      return api(url, config, 'POST', params);\n    },\n    attachments: {\n      // 전체 첨부파일 조회\n      retrieve: function retrieve(params) {\n        var url = \"\".concat(config.apiURL, \"/attachments\");\n        return api(url, config, 'GET', params);\n      },\n      \"delete\": function _delete(params) {\n        // 첨부파일 삭제\n        var url = \"\".concat(config.apiURL, \"/attachments/\").concat(params.attachment_id);\n        return api(url, config, 'DELETE', params);\n      }\n    },\n    settings: {\n      // 환경 설정\n      retrieve: function retrieve(params) {\n        var url = \"\".concat(config.apiURL, \"/settings\");\n        return api(url, config, 'PATCH', params);\n      }\n    },\n    group: {\n      retrieve: function retrieve() {\n        // 전체 그룹 조회\n        var url = \"\".concat(config.apiURL, \"/user_groups\");\n        return api(url, config, 'GET');\n      },\n      create: function create(params) {\n        // 그룹 생성\n        var url = \"\".concat(config.apiURL, \"/user_groups/create\");\n        return api(url, config, 'POST', params);\n      },\n      update: function update(params) {\n        // 그룹 수정\n        var url = \"\".concat(config.apiURL, \"/user_groups/\").concat(params.user_group_id);\n        return api(url, config, 'PATCH', params);\n      },\n      \"delete\": function _delete(params) {\n        // 그룹 삭제\n        var url = \"\".concat(config.apiURL, \"/user_groups/\").concat(params.user_group_id);\n        return api(url, config, 'DELETE', params);\n      },\n      updateMembers: function updateMembers(params) {\n        // 그룹 유저 추가/삭제\n        var url = \"\".concat(config.apiURL, \"/user_groups/\").concat(params.user_group_id, \"/members\");\n        return api(url, config, 'POST', params);\n      },\n      status: function status(params) {\n        // 유저가 그룹에 속했는지 여부\n        var url = \"\".concat(config.apiURL, \"/user_groups/\").concat(params.user_group_id, \"/members/\").concat(params.user_id);\n        return api(url, config, 'GET', params);\n      },\n      getUserGroupById: function getUserGroupById(params) {\n        // 그룹 id로 유저 목록 조회\n        var url = \"\".concat(config.apiURL, \"/user_groups/\").concat(params.user_group_id, \"/members\");\n        return api(url, config, 'GET', params);\n      }\n    }\n  };\n}\nmodule.exports = users;\n\n//# sourceURL=webpack://cw/./lib/resources/users.js?");

/***/ }),

/***/ "./lib/zuliprc.js":
/*!************************!*\
  !*** ./lib/zuliprc.js ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\"));\nvar _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/asyncToGenerator.js\"));\nvar _fs = __webpack_require__(/*! fs */ \"?d87b\");\nvar _ini = __webpack_require__(/*! ini */ \"./node_modules/ini/ini.js\");\nfunction parseConfigFile(_x) {\n  return _parseConfigFile.apply(this, arguments);\n}\nfunction _parseConfigFile() {\n  _parseConfigFile = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee(filename) {\n    var data, parsedConfig, config;\n    return _regenerator[\"default\"].wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return _fs.promises.readFile(filename, 'utf8');\n          case 2:\n            data = _context.sent;\n            parsedConfig = (0, _ini.parse)(data);\n            config = {\n              realm: parsedConfig.api.site,\n              username: parsedConfig.api.email,\n              apiKey: parsedConfig.api.key\n            };\n            config.apiURL = \"\".concat(parsedConfig.api.site, \"/api/v1\");\n            return _context.abrupt(\"return\", config);\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _parseConfigFile.apply(this, arguments);\n}\nvar _default = parseConfigFile;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack://cw/./lib/zuliprc.js?");

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack://cw/./node_modules/base64-js/index.js?");

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nconst base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nconst ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n\n\n//# sourceURL=webpack://cw/./node_modules/buffer/index.js?");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//# sourceURL=webpack://cw/./node_modules/ieee754/index.js?");

/***/ }),

/***/ "./node_modules/ini/ini.js":
/*!*********************************!*\
  !*** ./node_modules/ini/ini.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\nexports.parse = exports.decode = decode\n\nexports.stringify = exports.encode = encode\n\nexports.safe = safe\nexports.unsafe = unsafe\n\nvar eol = typeof process !== 'undefined' &&\n  process.platform === 'win32' ? '\\r\\n' : '\\n'\n\nfunction encode (obj, opt) {\n  var children = []\n  var out = ''\n\n  if (typeof opt === 'string') {\n    opt = {\n      section: opt,\n      whitespace: false,\n    }\n  } else {\n    opt = opt || {}\n    opt.whitespace = opt.whitespace === true\n  }\n\n  var separator = opt.whitespace ? ' = ' : '='\n\n  Object.keys(obj).forEach(function (k, _, __) {\n    var val = obj[k]\n    if (val && Array.isArray(val)) {\n      val.forEach(function (item) {\n        out += safe(k + '[]') + separator + safe(item) + '\\n'\n      })\n    } else if (val && typeof val === 'object')\n      children.push(k)\n    else\n      out += safe(k) + separator + safe(val) + eol\n  })\n\n  if (opt.section && out.length)\n    out = '[' + safe(opt.section) + ']' + eol + out\n\n  children.forEach(function (k, _, __) {\n    var nk = dotSplit(k).join('\\\\.')\n    var section = (opt.section ? opt.section + '.' : '') + nk\n    var child = encode(obj[k], {\n      section: section,\n      whitespace: opt.whitespace,\n    })\n    if (out.length && child.length)\n      out += eol\n\n    out += child\n  })\n\n  return out\n}\n\nfunction dotSplit (str) {\n  return str.replace(/\\1/g, '\\u0002LITERAL\\\\1LITERAL\\u0002')\n    .replace(/\\\\\\./g, '\\u0001')\n    .split(/\\./).map(function (part) {\n      return part.replace(/\\1/g, '\\\\.')\n        .replace(/\\2LITERAL\\\\1LITERAL\\2/g, '\\u0001')\n    })\n}\n\nfunction decode (str) {\n  var out = {}\n  var p = out\n  var section = null\n  //          section     |key      = value\n  var re = /^\\[([^\\]]*)\\]$|^([^=]+)(=(.*))?$/i\n  var lines = str.split(/[\\r\\n]+/g)\n\n  lines.forEach(function (line, _, __) {\n    if (!line || line.match(/^\\s*[;#]/))\n      return\n    var match = line.match(re)\n    if (!match)\n      return\n    if (match[1] !== undefined) {\n      section = unsafe(match[1])\n      if (section === '__proto__') {\n        // not allowed\n        // keep parsing the section, but don't attach it.\n        p = {}\n        return\n      }\n      p = out[section] = out[section] || {}\n      return\n    }\n    var key = unsafe(match[2])\n    if (key === '__proto__')\n      return\n    var value = match[3] ? unsafe(match[4]) : true\n    switch (value) {\n      case 'true':\n      case 'false':\n      case 'null': value = JSON.parse(value)\n    }\n\n    // Convert keys with '[]' suffix to an array\n    if (key.length > 2 && key.slice(-2) === '[]') {\n      key = key.substring(0, key.length - 2)\n      if (key === '__proto__')\n        return\n      if (!p[key])\n        p[key] = []\n      else if (!Array.isArray(p[key]))\n        p[key] = [p[key]]\n    }\n\n    // safeguard against resetting a previously defined\n    // array by accidentally forgetting the brackets\n    if (Array.isArray(p[key]))\n      p[key].push(value)\n    else\n      p[key] = value\n  })\n\n  // {a:{y:1},\"a.b\":{x:2}} --> {a:{y:1,b:{x:2}}}\n  // use a filter to return the keys that have to be deleted.\n  Object.keys(out).filter(function (k, _, __) {\n    if (!out[k] ||\n      typeof out[k] !== 'object' ||\n      Array.isArray(out[k]))\n      return false\n\n    // see if the parent section is also an object.\n    // if so, add it to that, and mark this one for deletion\n    var parts = dotSplit(k)\n    var p = out\n    var l = parts.pop()\n    var nl = l.replace(/\\\\\\./g, '.')\n    parts.forEach(function (part, _, __) {\n      if (part === '__proto__')\n        return\n      if (!p[part] || typeof p[part] !== 'object')\n        p[part] = {}\n      p = p[part]\n    })\n    if (p === out && nl === l)\n      return false\n\n    p[nl] = out[k]\n    return true\n  }).forEach(function (del, _, __) {\n    delete out[del]\n  })\n\n  return out\n}\n\nfunction isQuoted (val) {\n  return (val.charAt(0) === '\"' && val.slice(-1) === '\"') ||\n    (val.charAt(0) === \"'\" && val.slice(-1) === \"'\")\n}\n\nfunction safe (val) {\n  return (typeof val !== 'string' ||\n    val.match(/[=\\r\\n]/) ||\n    val.match(/^\\[/) ||\n    (val.length > 1 &&\n     isQuoted(val)) ||\n    val !== val.trim())\n    ? JSON.stringify(val)\n    : val.replace(/;/g, '\\\\;').replace(/#/g, '\\\\#')\n}\n\nfunction unsafe (val, doUnesc) {\n  val = (val || '').trim()\n  if (isQuoted(val)) {\n    // remove the single quotes before calling JSON.parse\n    if (val.charAt(0) === \"'\")\n      val = val.substr(1, val.length - 2)\n\n    try {\n      val = JSON.parse(val)\n    } catch (_) {}\n  } else {\n    // walk the val to find the first not-escaped ; character\n    var esc = false\n    var unesc = ''\n    for (var i = 0, l = val.length; i < l; i++) {\n      var c = val.charAt(i)\n      if (esc) {\n        if ('\\\\;#'.indexOf(c) !== -1)\n          unesc += c\n        else\n          unesc += '\\\\' + c\n\n        esc = false\n      } else if (';#'.indexOf(c) !== -1)\n        break\n      else if (c === '\\\\')\n        esc = true\n      else\n        unesc += c\n    }\n    if (esc)\n      unesc += '\\\\'\n\n    return unesc.trim()\n  }\n  return val\n}\n\n\n//# sourceURL=webpack://cw/./node_modules/ini/ini.js?");

/***/ }),

/***/ "./node_modules/isomorphic-fetch/fetch-npm-browserify.js":
/*!***************************************************************!*\
  !*** ./node_modules/isomorphic-fetch/fetch-npm-browserify.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// the whatwg-fetch polyfill installs the fetch() function\n// on the global object (window or self)\n//\n// Return that as the export for use in Webpack, Browserify etc.\n__webpack_require__(/*! whatwg-fetch */ \"./node_modules/whatwg-fetch/fetch.js\");\nmodule.exports = self.fetch.bind(self);\n\n\n//# sourceURL=webpack://cw/./node_modules/isomorphic-fetch/fetch-npm-browserify.js?");

/***/ }),

/***/ "./node_modules/isomorphic-form-data/lib/browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/isomorphic-form-data/lib/browser.js ***!
  \**********************************************************/
/***/ ((module) => {

eval("module.exports = window.FormData\n\n\n//# sourceURL=webpack://cw/./node_modules/isomorphic-form-data/lib/browser.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/***/ ((module) => {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack://cw/./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/whatwg-fetch/fetch.js":
/*!********************************************!*\
  !*** ./node_modules/whatwg-fetch/fetch.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DOMException\": () => (/* binding */ DOMException),\n/* harmony export */   \"Headers\": () => (/* binding */ Headers),\n/* harmony export */   \"Request\": () => (/* binding */ Request),\n/* harmony export */   \"Response\": () => (/* binding */ Response),\n/* harmony export */   \"fetch\": () => (/* binding */ fetch)\n/* harmony export */ });\nvar global =\n  (typeof globalThis !== 'undefined' && globalThis) ||\n  (typeof self !== 'undefined' && self) ||\n  (typeof global !== 'undefined' && global)\n\nvar support = {\n  searchParams: 'URLSearchParams' in global,\n  iterable: 'Symbol' in global && 'iterator' in Symbol,\n  blob:\n    'FileReader' in global &&\n    'Blob' in global &&\n    (function() {\n      try {\n        new Blob()\n        return true\n      } catch (e) {\n        return false\n      }\n    })(),\n  formData: 'FormData' in global,\n  arrayBuffer: 'ArrayBuffer' in global\n}\n\nfunction isDataView(obj) {\n  return obj && DataView.prototype.isPrototypeOf(obj)\n}\n\nif (support.arrayBuffer) {\n  var viewClasses = [\n    '[object Int8Array]',\n    '[object Uint8Array]',\n    '[object Uint8ClampedArray]',\n    '[object Int16Array]',\n    '[object Uint16Array]',\n    '[object Int32Array]',\n    '[object Uint32Array]',\n    '[object Float32Array]',\n    '[object Float64Array]'\n  ]\n\n  var isArrayBufferView =\n    ArrayBuffer.isView ||\n    function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    }\n}\n\nfunction normalizeName(name) {\n  if (typeof name !== 'string') {\n    name = String(name)\n  }\n  if (/[^a-z0-9\\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {\n    throw new TypeError('Invalid character in header field name: \"' + name + '\"')\n  }\n  return name.toLowerCase()\n}\n\nfunction normalizeValue(value) {\n  if (typeof value !== 'string') {\n    value = String(value)\n  }\n  return value\n}\n\n// Build a destructive iterator for the value list\nfunction iteratorFor(items) {\n  var iterator = {\n    next: function() {\n      var value = items.shift()\n      return {done: value === undefined, value: value}\n    }\n  }\n\n  if (support.iterable) {\n    iterator[Symbol.iterator] = function() {\n      return iterator\n    }\n  }\n\n  return iterator\n}\n\nfunction Headers(headers) {\n  this.map = {}\n\n  if (headers instanceof Headers) {\n    headers.forEach(function(value, name) {\n      this.append(name, value)\n    }, this)\n  } else if (Array.isArray(headers)) {\n    headers.forEach(function(header) {\n      this.append(header[0], header[1])\n    }, this)\n  } else if (headers) {\n    Object.getOwnPropertyNames(headers).forEach(function(name) {\n      this.append(name, headers[name])\n    }, this)\n  }\n}\n\nHeaders.prototype.append = function(name, value) {\n  name = normalizeName(name)\n  value = normalizeValue(value)\n  var oldValue = this.map[name]\n  this.map[name] = oldValue ? oldValue + ', ' + value : value\n}\n\nHeaders.prototype['delete'] = function(name) {\n  delete this.map[normalizeName(name)]\n}\n\nHeaders.prototype.get = function(name) {\n  name = normalizeName(name)\n  return this.has(name) ? this.map[name] : null\n}\n\nHeaders.prototype.has = function(name) {\n  return this.map.hasOwnProperty(normalizeName(name))\n}\n\nHeaders.prototype.set = function(name, value) {\n  this.map[normalizeName(name)] = normalizeValue(value)\n}\n\nHeaders.prototype.forEach = function(callback, thisArg) {\n  for (var name in this.map) {\n    if (this.map.hasOwnProperty(name)) {\n      callback.call(thisArg, this.map[name], name, this)\n    }\n  }\n}\n\nHeaders.prototype.keys = function() {\n  var items = []\n  this.forEach(function(value, name) {\n    items.push(name)\n  })\n  return iteratorFor(items)\n}\n\nHeaders.prototype.values = function() {\n  var items = []\n  this.forEach(function(value) {\n    items.push(value)\n  })\n  return iteratorFor(items)\n}\n\nHeaders.prototype.entries = function() {\n  var items = []\n  this.forEach(function(value, name) {\n    items.push([name, value])\n  })\n  return iteratorFor(items)\n}\n\nif (support.iterable) {\n  Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n}\n\nfunction consumed(body) {\n  if (body.bodyUsed) {\n    return Promise.reject(new TypeError('Already read'))\n  }\n  body.bodyUsed = true\n}\n\nfunction fileReaderReady(reader) {\n  return new Promise(function(resolve, reject) {\n    reader.onload = function() {\n      resolve(reader.result)\n    }\n    reader.onerror = function() {\n      reject(reader.error)\n    }\n  })\n}\n\nfunction readBlobAsArrayBuffer(blob) {\n  var reader = new FileReader()\n  var promise = fileReaderReady(reader)\n  reader.readAsArrayBuffer(blob)\n  return promise\n}\n\nfunction readBlobAsText(blob) {\n  var reader = new FileReader()\n  var promise = fileReaderReady(reader)\n  reader.readAsText(blob)\n  return promise\n}\n\nfunction readArrayBufferAsText(buf) {\n  var view = new Uint8Array(buf)\n  var chars = new Array(view.length)\n\n  for (var i = 0; i < view.length; i++) {\n    chars[i] = String.fromCharCode(view[i])\n  }\n  return chars.join('')\n}\n\nfunction bufferClone(buf) {\n  if (buf.slice) {\n    return buf.slice(0)\n  } else {\n    var view = new Uint8Array(buf.byteLength)\n    view.set(new Uint8Array(buf))\n    return view.buffer\n  }\n}\n\nfunction Body() {\n  this.bodyUsed = false\n\n  this._initBody = function(body) {\n    /*\n      fetch-mock wraps the Response object in an ES6 Proxy to\n      provide useful test harness features such as flush. However, on\n      ES5 browsers without fetch or Proxy support pollyfills must be used;\n      the proxy-pollyfill is unable to proxy an attribute unless it exists\n      on the object before the Proxy is created. This change ensures\n      Response.bodyUsed exists on the instance, while maintaining the\n      semantic of setting Request.bodyUsed in the constructor before\n      _initBody is called.\n    */\n    this.bodyUsed = this.bodyUsed\n    this._bodyInit = body\n    if (!body) {\n      this._bodyText = ''\n    } else if (typeof body === 'string') {\n      this._bodyText = body\n    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n      this._bodyBlob = body\n    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n      this._bodyFormData = body\n    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n      this._bodyText = body.toString()\n    } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n      this._bodyArrayBuffer = bufferClone(body.buffer)\n      // IE 10-11 can't handle a DataView body.\n      this._bodyInit = new Blob([this._bodyArrayBuffer])\n    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n      this._bodyArrayBuffer = bufferClone(body)\n    } else {\n      this._bodyText = body = Object.prototype.toString.call(body)\n    }\n\n    if (!this.headers.get('content-type')) {\n      if (typeof body === 'string') {\n        this.headers.set('content-type', 'text/plain;charset=UTF-8')\n      } else if (this._bodyBlob && this._bodyBlob.type) {\n        this.headers.set('content-type', this._bodyBlob.type)\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n      }\n    }\n  }\n\n  if (support.blob) {\n    this.blob = function() {\n      var rejected = consumed(this)\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return Promise.resolve(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as blob')\n      } else {\n        return Promise.resolve(new Blob([this._bodyText]))\n      }\n    }\n\n    this.arrayBuffer = function() {\n      if (this._bodyArrayBuffer) {\n        var isConsumed = consumed(this)\n        if (isConsumed) {\n          return isConsumed\n        }\n        if (ArrayBuffer.isView(this._bodyArrayBuffer)) {\n          return Promise.resolve(\n            this._bodyArrayBuffer.buffer.slice(\n              this._bodyArrayBuffer.byteOffset,\n              this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength\n            )\n          )\n        } else {\n          return Promise.resolve(this._bodyArrayBuffer)\n        }\n      } else {\n        return this.blob().then(readBlobAsArrayBuffer)\n      }\n    }\n  }\n\n  this.text = function() {\n    var rejected = consumed(this)\n    if (rejected) {\n      return rejected\n    }\n\n    if (this._bodyBlob) {\n      return readBlobAsText(this._bodyBlob)\n    } else if (this._bodyArrayBuffer) {\n      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n    } else if (this._bodyFormData) {\n      throw new Error('could not read FormData body as text')\n    } else {\n      return Promise.resolve(this._bodyText)\n    }\n  }\n\n  if (support.formData) {\n    this.formData = function() {\n      return this.text().then(decode)\n    }\n  }\n\n  this.json = function() {\n    return this.text().then(JSON.parse)\n  }\n\n  return this\n}\n\n// HTTP methods whose capitalization should be normalized\nvar methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\nfunction normalizeMethod(method) {\n  var upcased = method.toUpperCase()\n  return methods.indexOf(upcased) > -1 ? upcased : method\n}\n\nfunction Request(input, options) {\n  if (!(this instanceof Request)) {\n    throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.')\n  }\n\n  options = options || {}\n  var body = options.body\n\n  if (input instanceof Request) {\n    if (input.bodyUsed) {\n      throw new TypeError('Already read')\n    }\n    this.url = input.url\n    this.credentials = input.credentials\n    if (!options.headers) {\n      this.headers = new Headers(input.headers)\n    }\n    this.method = input.method\n    this.mode = input.mode\n    this.signal = input.signal\n    if (!body && input._bodyInit != null) {\n      body = input._bodyInit\n      input.bodyUsed = true\n    }\n  } else {\n    this.url = String(input)\n  }\n\n  this.credentials = options.credentials || this.credentials || 'same-origin'\n  if (options.headers || !this.headers) {\n    this.headers = new Headers(options.headers)\n  }\n  this.method = normalizeMethod(options.method || this.method || 'GET')\n  this.mode = options.mode || this.mode || null\n  this.signal = options.signal || this.signal\n  this.referrer = null\n\n  if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n    throw new TypeError('Body not allowed for GET or HEAD requests')\n  }\n  this._initBody(body)\n\n  if (this.method === 'GET' || this.method === 'HEAD') {\n    if (options.cache === 'no-store' || options.cache === 'no-cache') {\n      // Search for a '_' parameter in the query string\n      var reParamSearch = /([?&])_=[^&]*/\n      if (reParamSearch.test(this.url)) {\n        // If it already exists then set the value with the current time\n        this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime())\n      } else {\n        // Otherwise add a new '_' parameter to the end with the current time\n        var reQueryString = /\\?/\n        this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime()\n      }\n    }\n  }\n}\n\nRequest.prototype.clone = function() {\n  return new Request(this, {body: this._bodyInit})\n}\n\nfunction decode(body) {\n  var form = new FormData()\n  body\n    .trim()\n    .split('&')\n    .forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n  return form\n}\n\nfunction parseHeaders(rawHeaders) {\n  var headers = new Headers()\n  // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n  // https://tools.ietf.org/html/rfc7230#section-3.2\n  var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ')\n  // Avoiding split via regex to work around a common IE11 bug with the core-js 3.6.0 regex polyfill\n  // https://github.com/github/fetch/issues/748\n  // https://github.com/zloirock/core-js/issues/751\n  preProcessedHeaders\n    .split('\\r')\n    .map(function(header) {\n      return header.indexOf('\\n') === 0 ? header.substr(1, header.length) : header\n    })\n    .forEach(function(line) {\n      var parts = line.split(':')\n      var key = parts.shift().trim()\n      if (key) {\n        var value = parts.join(':').trim()\n        headers.append(key, value)\n      }\n    })\n  return headers\n}\n\nBody.call(Request.prototype)\n\nfunction Response(bodyInit, options) {\n  if (!(this instanceof Response)) {\n    throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.')\n  }\n  if (!options) {\n    options = {}\n  }\n\n  this.type = 'default'\n  this.status = options.status === undefined ? 200 : options.status\n  this.ok = this.status >= 200 && this.status < 300\n  this.statusText = options.statusText === undefined ? '' : '' + options.statusText\n  this.headers = new Headers(options.headers)\n  this.url = options.url || ''\n  this._initBody(bodyInit)\n}\n\nBody.call(Response.prototype)\n\nResponse.prototype.clone = function() {\n  return new Response(this._bodyInit, {\n    status: this.status,\n    statusText: this.statusText,\n    headers: new Headers(this.headers),\n    url: this.url\n  })\n}\n\nResponse.error = function() {\n  var response = new Response(null, {status: 0, statusText: ''})\n  response.type = 'error'\n  return response\n}\n\nvar redirectStatuses = [301, 302, 303, 307, 308]\n\nResponse.redirect = function(url, status) {\n  if (redirectStatuses.indexOf(status) === -1) {\n    throw new RangeError('Invalid status code')\n  }\n\n  return new Response(null, {status: status, headers: {location: url}})\n}\n\nvar DOMException = global.DOMException\ntry {\n  new DOMException()\n} catch (err) {\n  DOMException = function(message, name) {\n    this.message = message\n    this.name = name\n    var error = Error(message)\n    this.stack = error.stack\n  }\n  DOMException.prototype = Object.create(Error.prototype)\n  DOMException.prototype.constructor = DOMException\n}\n\nfunction fetch(input, init) {\n  return new Promise(function(resolve, reject) {\n    var request = new Request(input, init)\n\n    if (request.signal && request.signal.aborted) {\n      return reject(new DOMException('Aborted', 'AbortError'))\n    }\n\n    var xhr = new XMLHttpRequest()\n\n    function abortXhr() {\n      xhr.abort()\n    }\n\n    xhr.onload = function() {\n      var options = {\n        status: xhr.status,\n        statusText: xhr.statusText,\n        headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n      }\n      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n      var body = 'response' in xhr ? xhr.response : xhr.responseText\n      setTimeout(function() {\n        resolve(new Response(body, options))\n      }, 0)\n    }\n\n    xhr.onerror = function() {\n      setTimeout(function() {\n        reject(new TypeError('Network request failed'))\n      }, 0)\n    }\n\n    xhr.ontimeout = function() {\n      setTimeout(function() {\n        reject(new TypeError('Network request failed'))\n      }, 0)\n    }\n\n    xhr.onabort = function() {\n      setTimeout(function() {\n        reject(new DOMException('Aborted', 'AbortError'))\n      }, 0)\n    }\n\n    function fixUrl(url) {\n      try {\n        return url === '' && global.location.href ? global.location.href : url\n      } catch (e) {\n        return url\n      }\n    }\n\n    xhr.open(request.method, fixUrl(request.url), true)\n\n    if (request.credentials === 'include') {\n      xhr.withCredentials = true\n    } else if (request.credentials === 'omit') {\n      xhr.withCredentials = false\n    }\n\n    if ('responseType' in xhr) {\n      if (support.blob) {\n        xhr.responseType = 'blob'\n      } else if (\n        support.arrayBuffer &&\n        request.headers.get('Content-Type') &&\n        request.headers.get('Content-Type').indexOf('application/octet-stream') !== -1\n      ) {\n        xhr.responseType = 'arraybuffer'\n      }\n    }\n\n    if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers)) {\n      Object.getOwnPropertyNames(init.headers).forEach(function(name) {\n        xhr.setRequestHeader(name, normalizeValue(init.headers[name]))\n      })\n    } else {\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n    }\n\n    if (request.signal) {\n      request.signal.addEventListener('abort', abortXhr)\n\n      xhr.onreadystatechange = function() {\n        // DONE (success or failure)\n        if (xhr.readyState === 4) {\n          request.signal.removeEventListener('abort', abortXhr)\n        }\n      }\n    }\n\n    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n  })\n}\n\nfetch.polyfill = true\n\nif (!global.fetch) {\n  global.fetch = fetch\n  global.Headers = Headers\n  global.Request = Request\n  global.Response = Response\n}\n\n\n//# sourceURL=webpack://cw/./node_modules/whatwg-fetch/fetch.js?");

/***/ }),

/***/ "?d87b":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://cw/fs_(ignored)?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayLikeToArray.js ***!
  \*****************************************************************/
/***/ ((module) => {

eval("function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nmodule.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://cw/./node_modules/@babel/runtime/helpers/arrayLikeToArray.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithHoles.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nmodule.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://cw/./node_modules/@babel/runtime/helpers/arrayWithHoles.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/asyncToGenerator.js ***!
  \*****************************************************************/
/***/ ((module) => {

eval("function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}\nmodule.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://cw/./node_modules/@babel/runtime/helpers/asyncToGenerator.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/defineProperty.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var toPropertyKey = __webpack_require__(/*! ./toPropertyKey.js */ \"./node_modules/@babel/runtime/helpers/toPropertyKey.js\");\nfunction _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nmodule.exports = _defineProperty, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://cw/./node_modules/@babel/runtime/helpers/defineProperty.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("function _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\nmodule.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://cw/./node_modules/@babel/runtime/helpers/interopRequireDefault.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js ***!
  \*********************************************************************/
/***/ ((module) => {

eval("function _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) {\n        ;\n      }\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}\nmodule.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://cw/./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableRest.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableRest.js ***!
  \****************************************************************/
/***/ ((module) => {

eval("function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nmodule.exports = _nonIterableRest, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://cw/./node_modules/@babel/runtime/helpers/nonIterableRest.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/regeneratorRuntime.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/regeneratorRuntime.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var _typeof = (__webpack_require__(/*! ./typeof.js */ \"./node_modules/@babel/runtime/helpers/typeof.js\")[\"default\"]);\nfunction _regeneratorRuntime() {\n  \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */\n  module.exports = _regeneratorRuntime = function _regeneratorRuntime() {\n    return exports;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  var exports = {},\n    Op = Object.prototype,\n    hasOwn = Op.hasOwnProperty,\n    defineProperty = Object.defineProperty || function (obj, key, desc) {\n      obj[key] = desc.value;\n    },\n    $Symbol = \"function\" == typeof Symbol ? Symbol : {},\n    iteratorSymbol = $Symbol.iterator || \"@@iterator\",\n    asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\",\n    toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n  function define(obj, key, value) {\n    return Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }), obj[key];\n  }\n  try {\n    define({}, \"\");\n  } catch (err) {\n    define = function define(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,\n      generator = Object.create(protoGenerator.prototype),\n      context = new Context(tryLocsList || []);\n    return defineProperty(generator, \"_invoke\", {\n      value: makeInvokeMethod(innerFn, self, context)\n    }), generator;\n  }\n  function tryCatch(fn, obj, arg) {\n    try {\n      return {\n        type: \"normal\",\n        arg: fn.call(obj, arg)\n      };\n    } catch (err) {\n      return {\n        type: \"throw\",\n        arg: err\n      };\n    }\n  }\n  exports.wrap = wrap;\n  var ContinueSentinel = {};\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n  var getProto = Object.getPrototypeOf,\n    NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function (method) {\n      define(prototype, method, function (arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (\"throw\" !== record.type) {\n        var result = record.arg,\n          value = result.value;\n        return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) {\n          invoke(\"next\", value, resolve, reject);\n        }, function (err) {\n          invoke(\"throw\", err, resolve, reject);\n        }) : PromiseImpl.resolve(value).then(function (unwrapped) {\n          result.value = unwrapped, resolve(result);\n        }, function (error) {\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n      reject(record.arg);\n    }\n    var previousPromise;\n    defineProperty(this, \"_invoke\", {\n      value: function value(method, arg) {\n        function callInvokeWithMethodAndArg() {\n          return new PromiseImpl(function (resolve, reject) {\n            invoke(method, arg, resolve, reject);\n          });\n        }\n        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n      }\n    });\n  }\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = \"suspendedStart\";\n    return function (method, arg) {\n      if (\"executing\" === state) throw new Error(\"Generator is already running\");\n      if (\"completed\" === state) {\n        if (\"throw\" === method) throw arg;\n        return doneResult();\n      }\n      for (context.method = method, context.arg = arg;;) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n        if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) {\n          if (\"suspendedStart\" === state) throw state = \"completed\", context.arg;\n          context.dispatchException(context.arg);\n        } else \"return\" === context.method && context.abrupt(\"return\", context.arg);\n        state = \"executing\";\n        var record = tryCatch(innerFn, self, context);\n        if (\"normal\" === record.type) {\n          if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue;\n          return {\n            value: record.arg,\n            done: context.done\n          };\n        }\n        \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg);\n      }\n    };\n  }\n  function maybeInvokeDelegate(delegate, context) {\n    var methodName = context.method,\n      method = delegate.iterator[methodName];\n    if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel;\n    var record = tryCatch(method, delegate.iterator, context.arg);\n    if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel;\n    var info = record.arg;\n    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel);\n  }\n  function pushTryEntry(locs) {\n    var entry = {\n      tryLoc: locs[0]\n    };\n    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);\n  }\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\", delete record.arg, entry.completion = record;\n  }\n  function Context(tryLocsList) {\n    this.tryEntries = [{\n      tryLoc: \"root\"\n    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);\n  }\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) return iteratorMethod.call(iterable);\n      if (\"function\" == typeof iterable.next) return iterable;\n      if (!isNaN(iterable.length)) {\n        var i = -1,\n          next = function next() {\n            for (; ++i < iterable.length;) {\n              if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;\n            }\n            return next.value = undefined, next.done = !0, next;\n          };\n        return next.next = next;\n      }\n    }\n    return {\n      next: doneResult\n    };\n  }\n  function doneResult() {\n    return {\n      value: undefined,\n      done: !0\n    };\n  }\n  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", {\n    value: GeneratorFunctionPrototype,\n    configurable: !0\n  }), defineProperty(GeneratorFunctionPrototype, \"constructor\", {\n    value: GeneratorFunction,\n    configurable: !0\n  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) {\n    var ctor = \"function\" == typeof genFun && genFun.constructor;\n    return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name));\n  }, exports.mark = function (genFun) {\n    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun;\n  }, exports.awrap = function (arg) {\n    return {\n      __await: arg\n    };\n  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    void 0 === PromiseImpl && (PromiseImpl = Promise);\n    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {\n      return result.done ? result.value : iter.next();\n    });\n  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () {\n    return this;\n  }), define(Gp, \"toString\", function () {\n    return \"[object Generator]\";\n  }), exports.keys = function (val) {\n    var object = Object(val),\n      keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    return keys.reverse(), function next() {\n      for (; keys.length;) {\n        var key = keys.pop();\n        if (key in object) return next.value = key, next.done = !1, next;\n      }\n      return next.done = !0, next;\n    };\n  }, exports.values = values, Context.prototype = {\n    constructor: Context,\n    reset: function reset(skipTempReset) {\n      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) {\n        \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);\n      }\n    },\n    stop: function stop() {\n      this.done = !0;\n      var rootRecord = this.tryEntries[0].completion;\n      if (\"throw\" === rootRecord.type) throw rootRecord.arg;\n      return this.rval;\n    },\n    dispatchException: function dispatchException(exception) {\n      if (this.done) throw exception;\n      var context = this;\n      function handle(loc, caught) {\n        return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught;\n      }\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i],\n          record = entry.completion;\n        if (\"root\" === entry.tryLoc) return handle(\"end\");\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\"),\n            hasFinally = hasOwn.call(entry, \"finallyLoc\");\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);\n            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);\n          } else {\n            if (!hasFinally) throw new Error(\"try statement without catch or finally\");\n            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);\n          }\n        }\n      }\n    },\n    abrupt: function abrupt(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n      finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);\n      var record = finallyEntry ? finallyEntry.completion : {};\n      return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);\n    },\n    complete: function complete(record, afterLoc) {\n      if (\"throw\" === record.type) throw record.arg;\n      return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;\n    },\n    finish: function finish(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;\n      }\n    },\n    \"catch\": function _catch(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (\"throw\" === record.type) {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n      throw new Error(\"illegal catch attempt\");\n    },\n    delegateYield: function delegateYield(iterable, resultName, nextLoc) {\n      return this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel;\n    }\n  }, exports;\n}\nmodule.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://cw/./node_modules/@babel/runtime/helpers/regeneratorRuntime.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/slicedToArray.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/slicedToArray.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var arrayWithHoles = __webpack_require__(/*! ./arrayWithHoles.js */ \"./node_modules/@babel/runtime/helpers/arrayWithHoles.js\");\nvar iterableToArrayLimit = __webpack_require__(/*! ./iterableToArrayLimit.js */ \"./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js\");\nvar unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray.js */ \"./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js\");\nvar nonIterableRest = __webpack_require__(/*! ./nonIterableRest.js */ \"./node_modules/@babel/runtime/helpers/nonIterableRest.js\");\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}\nmodule.exports = _slicedToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://cw/./node_modules/@babel/runtime/helpers/slicedToArray.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/toPrimitive.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toPrimitive.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var _typeof = (__webpack_require__(/*! ./typeof.js */ \"./node_modules/@babel/runtime/helpers/typeof.js\")[\"default\"]);\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nmodule.exports = _toPrimitive, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://cw/./node_modules/@babel/runtime/helpers/toPrimitive.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/toPropertyKey.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toPropertyKey.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var _typeof = (__webpack_require__(/*! ./typeof.js */ \"./node_modules/@babel/runtime/helpers/typeof.js\")[\"default\"]);\nvar toPrimitive = __webpack_require__(/*! ./toPrimitive.js */ \"./node_modules/@babel/runtime/helpers/toPrimitive.js\");\nfunction _toPropertyKey(arg) {\n  var key = toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nmodule.exports = _toPropertyKey, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://cw/./node_modules/@babel/runtime/helpers/toPropertyKey.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return (module.exports = _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports), _typeof(obj);\n}\nmodule.exports = _typeof, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://cw/./node_modules/@babel/runtime/helpers/typeof.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray.js */ \"./node_modules/@babel/runtime/helpers/arrayLikeToArray.js\");\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\nmodule.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://cw/./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// TODO(Babel 8): Remove this file.\n\nvar runtime = __webpack_require__(/*! ../helpers/regeneratorRuntime */ \"./node_modules/@babel/runtime/helpers/regeneratorRuntime.js\")();\nmodule.exports = runtime;\n\n// Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n\n\n//# sourceURL=webpack://cw/./node_modules/@babel/runtime/regenerator/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./browser/zulip_cherry_main.js");
/******/ 	cw = __webpack_exports__;
/******/ 	
/******/ })()
;